<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The UNIX Time-Sharing System</title>
      <link href="/2024/02/25/The-UNIX-Time-Sharing-System/"/>
      <url>/2024/02/25/The-UNIX-Time-Sharing-System/</url>
      
        <content type="html"><![CDATA[<h1 id="OSDI’-73-The-UNIX-Time-Sharing-System"><a href="#OSDI’-73-The-UNIX-Time-Sharing-System" class="headerlink" title="[OSDI’ 73] The UNIX Time-Sharing System"></a>[OSDI’ 73] The UNIX Time-Sharing System</h1><h2 id="0-Word-Bank"><a href="#0-Word-Bank" class="headerlink" title="0. Word Bank"></a>0. Word Bank</h2><table><thead><tr><th align="center">单词</th><th align="center">中文释义</th><th align="center">单词</th><th align="center">中文释义</th></tr></thead><tbody><tr><td align="center">demountable</td><td align="center">可卸下的</td><td align="center">compatible</td><td align="center">可兼容的</td></tr><tr><td align="center">asynchronous</td><td align="center">异步的</td><td align="center">allotment</td><td align="center">份额</td></tr><tr><td align="center">baud</td><td align="center">波特（专）</td><td align="center">miscellaneous</td><td align="center">五花八门的</td></tr><tr><td align="center">preponderance</td><td align="center">数量众多</td><td align="center">reentrant</td><td align="center">可自进入的</td></tr><tr><td align="center">demarcated</td><td align="center">被区分</td><td align="center">general-purpose</td><td align="center">多用途的</td></tr><tr><td align="center">overhead</td><td align="center">延迟</td><td align="center">bootstrap</td><td align="center">创造</td></tr><tr><td align="center">mesh</td><td align="center">网格</td><td align="center">antagonistic</td><td align="center">敌对的</td></tr></tbody></table><h2 id="1-Abstract-Introduction"><a href="#1-Abstract-Introduction" class="headerlink" title="1. Abstract&#x2F;Introduction"></a>1. Abstract&#x2F;Introduction</h2><p>UNIX 是一个多用途&#x2F;多用户&#x2F;可交互的操作系统。它有很多优秀且独特的特点：</p><ul><li>一个有级别的文件系统，其中有<strong>可拆卸的部分 (mount)</strong></li><li>可兼容文件&#x2F;设备&#x2F;进程间I&#x2F;O(pipe)</li><li>可启动异步进程</li><li>用户可通过命令行来操作系统</li><li>用很多子系统、十几种语言（例如一个 C 编译器、文本编辑、汇编器……）</li><li>非常便携</li></ul><p>UNIX 在当时的时代最主要的成就是在性能优异、功能丰富的同时减少了开销。不仅于此，UNIX系统也非常优雅、简洁。于是我们可以开始看接下来的内容了。</p><h2 id="2-Hardware-and-Software-Environment"><a href="#2-Hardware-and-Software-Environment" class="headerlink" title="2. Hardware and Software Environment"></a>2. Hardware and Software Environment</h2><p>这里直接引用 <a href="https://github.com/whr-a">@王浩然</a> 的 slides，我觉得已经说的很精确了。</p><blockquote><ul><li>最早的版本运行在 Digital 公司的 PDP-7 和 PDP-9 计算机上。论文讨论的是 PDP-11 &#x2F; 40和 PDP-45 系统，运行的 UNIX 更成熟。</li><li>PDP-11&#x2F;45 有 16 位字长 (16bit)，具有 144kb 的核心内存。实际运行 UNIX 最小只需要 50kb 字节的内核。</li><li>1973 年以后，UNIX 用 C 语言重写了一遍，更易于理解与修改，包括了许多函数的改进。（因为已经有比较好</li></ul></blockquote><h2 id="3-The-File-System"><a href="#3-The-File-System" class="headerlink" title="3. The File System"></a>3. The File System</h2><p>文件主要分为三种，正常磁盘文件，目录和特殊文件。注意，特殊文件实际上就是 I&#x2F;O 设备等，这样的抽象能方便兼容性，也能统一管理。</p><h3 id="3-1-普通文件"><a href="#3-1-普通文件" class="headerlink" title="3.1 普通文件"></a>3.1 普通文件</h3><p>普通文件中，信息按照顺序地被存储，最后有结束标志。而二进制文件则是其它存储信息的方式，这些信息可能在开机时被读入主存。</p><p>例如，如果我要存储 $3.1415927$，在文本文件中就需要存储这 9 个字符，需要 9 个 $\text{ASCII}$ 值，而二进制文件只需要 4 个字节（$DB\ 0F\ 49\ 40$）。</p><h3 id="3-2-目录和文件结构"><a href="#3-2-目录和文件结构" class="headerlink" title="3.2 目录和文件结构"></a>3.2 目录和文件结构</h3><p>目录给文件系统提供了结构。它也可以被看作一个普通文件，有权限的人才能进入之或在其中进行修改（相当于读写文件）。</p><p>UNIX 文件系统的根是 <strong>root</strong> 目录，另外也会把一些指令以文件的形式存在系统目录中。</p><p>文件有同一的命名标准，也有 <code>cd</code> 的方式（包括 <code>./..</code> 这类），这些不再赘述。</p><hr><p>值得注意的是 UNIX 中的 <strong>linking</strong> 特性：同一个文件可以在不同目录下以不同文件名存在。本质而言，这是因为 UNIX </p><p>关于文件结构，我们选择<strong>严格遵循有根树结构</strong>。这样可以简化目录遍历，维护层级一致性，简化管理。更重要的是，如果允许目录间链接，可能会出现循环和孤立的目录，导致资源管理和垃圾回收的问题。</p><hr><h3 id="3-3-特殊文件"><a href="#3-3-特殊文件" class="headerlink" title="3.3 特殊文件"></a>3.3 特殊文件</h3><p>这是 UNIX 文件系统最特殊的功能。本质而言，每个 I&#x2F;O 设备都与至少一个这样的文件想管来奶。特殊文件有这样一些一些性质：</p><ul><li>特殊文件的读取和写入从接口上而言和普通文件一致，但会激活关联设备</li><li>条目位于 <code>/dev</code> 中</li></ul><p>这种设备-&gt;文件的抽象有<strong>三重优势</strong>：可以调用文件读写来进行 I&#x2F;O&#x2F;文件名和设备名名称语法和含义相同，因而方便传参&#x2F;保护机制相同</p><h3 id="3-4-可移除的文件系统"><a href="#3-4-可移除的文件系统" class="headerlink" title="3.4 可移除的文件系统"></a>3.4 可移除的文件系统</h3><p>事实上，我们并不需要整个文件系统都储存在这台设备上，文件当然可以被存在 DVD 等被插入的设备上。<code>mount</code> 指令可以帮我们解决：</p><p><img src="/2024/02/25/The-UNIX-Time-Sharing-System/manMount.png"></p><p>这样，我们就能把 <code>mount</code> 到的 ordinary file 重定向到新文件系统的根目录，即把原文件树的叶结点换成了一个新树。之后就可以直接通过挂载的目录来修改原可移动卷 (removable volume) 上的文件。唯一要注意的是两个不同的文件系统之间不能有链接。如果允许，在卸下可移动卷的时候，需要解除所有的链接，这是很繁琐的。</p><h3 id="3-5-保护"><a href="#3-5-保护" class="headerlink" title="3.5 保护"></a>3.5 保护</h3><p>对于每个文件来说，有创建用户&#x2F;组内其他用户&#x2F;其他用户三类用户。当用户创建文件时，将会在其中以自己独特的 UID 进行标记。文件保护码是 10 位，9 位代表该用户&#x2F;组内其他用户&#x2F;其他用户的读写执行权限。</p><p>第 10 位是 set-user-ID 位，假设只有 A 程序的创建者 him 拥有读写它自己的权限，但它的这一位被设置，用户 me 运行的 B 程序就可以在执行 A 程序的时候进行对它自己的读写。这是因为在执行时，检测到 A 的 set-user-ID bit is on，然后就会在执行时暂时地将 me 的 UID 改为 him，这样就能执行了。这一设计<strong>可用于允许用户执行精心编写的调用特权系统条目的命令，并提供特权程序</strong>。</p><p>整个系统有一个 super-user，它可以进行所有的操作。</p><h3 id="3-6-I-O-调用"><a href="#3-6-I-O-调用" class="headerlink" title="3.6 I&#x2F;O 调用"></a>3.6 I&#x2F;O 调用</h3><p>我们主要有如下 I&#x2F;O 操作（用 C 语言描述）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filep = <span class="built_in">open</span>(name, flag);</span><br><span class="line">n = <span class="built_in">read</span>(filep, buffer, count);</span><br><span class="line">n = <span class="built_in">write</span>(filep, buffer, count);</span><br><span class="line">location = <span class="built_in">lseek</span>(filep, offset, base);</span><br></pre></td></tr></table></figure><p>name 代表文件名，flag 代表我们要进行的操作（读&#x2F;写&#x2F;都有），<code>filep</code> 代表 **文件描述符(file descriptor)**，是一个用来表征文件的整数，可以通过该参数来表示操作哪个文件。count 代表想要读写的字节数，如果读到末尾了返回值就小于 count，否则就会返回 count（除非有错误）。<code>write</code> 是覆盖式的，且在末尾写的时候会让文件变大。而 <code>lseek</code> 顾名思义，是把 <code>filep</code> 的指针移动，其中 <code>offset</code> 可能为负。当然，对于一个打印机，你进行 <code>lseek</code> 操作是无意义的。</p><p>关于 I&#x2F;O 还有一些操作，诸如关闭文件&#x2F;获取文件状态&#x2F;改变保护形式&#x2F;改变所有者……</p><hr><p>关于锁，UNIX 系统认为用户不需要管一致性，因为管了也没用。</p><p><strong>非必要性</strong>：不会有大的单文件被多进程维护的情形。</p><p><strong>非充分性</strong>：在两个用户同时在编辑文件的时候，文本编辑器本质上是创造了文件的两个拷贝，所以加了锁也没用。</p><hr><h2 id="4-Implementation-of-the-File-System"><a href="#4-Implementation-of-the-File-System" class="headerlink" title="4. Implementation of the File System"></a>4. Implementation of the File System</h2><p><a href=""></a>提到目录内维护的是指向文件的指针 <em>i-number</em>。访问文件时，i-number 作索引找到 i-node，i-node 由若干描述组成，比如所有者、保护位、文件内容的物理磁盘地址或磁带地址、被引用的次数、指示文件是否为目录、特殊文件、“大”还是“小”。这个表被存在一个系统已知的地方。</p><p>当创造文件的时候，就会分配一个 i-node 给该文件，并在目录中维护 name -&gt; i-number 的新表项。link 的时候就相当于增加该表表项，并复制源文件的 i-number，并增加 i-node 的 <em>link-count</em>（这样决定啥时候释放 i-node 的空间）。</p><hr><p><strong>关于磁盘上的空间分配</strong>：我们把磁盘分成 512b 的一些块。每个 in-node 对应的地址空间里含有 13 份地址。对普通文件，前 10 份是指向前 10 个块。如果数据比 10 块大，第 11 份便指向一个中继块，其中有 128 个额外块的地址。第 12、13 位依此类推，最多可存 $512\cdot (10 + 128 + 128^2 + 128^3)$ bytes。</p><p><strong>特殊文件的 i-node</strong>：最后 12 个设备地址不重要，仅解释为两个字节，分别指定设备类型和子设备号，这两个字节合称为<em>设备名</em>。</p><hr><p><strong>mount 的实现</strong>：当要挂载时，mount 指令维护一个系统表，为一个普通文件 i-number+设备名到特殊文件设备名的映射。<br>比如根目录中有 ABC 三个文件，分别挂载了三个可移动磁盘，现在访问 &#x2F;B&#x2F;123，则在匹配 B 的时候在系统表里面查找到映射，i-number 被替换成 1（这是所有文件系统上根目录的  i-number），设备名被替换成映射对应的值，即特殊文件设备名。</p><hr><p><strong>关于 I&#x2F;O 的实现</strong>：尽管对于用户而言是可以立刻进行的，但实际上并不是，我们会维护一个缓冲区。写的时候先查看缓冲区，如果在其中就进行标记，而真正的 I&#x2F;O 操作会延迟。</p><p>另外，当认为程序在进行顺序读写的时候，会异步地提前读取下一个块，这样可以大大地减少运行时间，而增加少许开销。</p><h2 id="5-Processes-and-Images"><a href="#5-Processes-and-Images" class="headerlink" title="5. Processes and Images"></a>5. Processes and Images</h2><p><strong>映像 (image)</strong> 是指计算机的运行环境，包括内存映像、寄存器值、开关文件信息、目前环境等。对于每个进程来说，这就是它全部的信息。</p><p><strong>进程 (process)</strong> 是一个映像的执行。当它被执行时，映像必须在主存中，除非有一个活跃的&#x2F;高优先级的进程迫使其回到磁盘。</p><p><img src="/2024/02/25/The-UNIX-Time-Sharing-System/processSpace.png"></p><p>进程映像的内存部分分为三段：第一是正文段（如程序代码），这个是写保护的，根，它可以在备份间共享；第二是数据段，它是可写的，在最下面，向上增长；第三是堆栈段，它会随着栈指针的移动向下增长。</p><hr><h3 id="5-1-进程"><a href="#5-1-进程" class="headerlink" title="5.1 进程"></a>5.1 进程</h3><p>除了第一个系统启动的进程，剩下的只需要用 <code>fork</code> 来产生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processid = fork();</span><br></pre></td></tr></table></figure><p>每个进程有自己独特的 <code>processid</code>，然后一开始拥有相同的内存映像、打开文件……两者的不同在于，在父进程中，<code>processid</code> 不为 0，子进程的 pid，而在子进程中，该值为 0。</p><h3 id="5-2-管道"><a href="#5-2-管道" class="headerlink" title="5.2 管道"></a>5.2 管道</h3><p>管道是 UNIX 中的一个很棒的设计。调用管道通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filep = <span class="built_in">pipe</span>();</span><br></pre></td></tr></table></figure><p>这时候就可以用 <code>filep</code> 来调用管道。管道的一个特性是，你在其中的每个读都会等到另一个使用管道的进程写完之后操作。</p><p>在我看来，它的精彩在于结合了进程间通信和文件读写，而不需要共享内存映像啥的，并且在使用上也只需要用 <code>|</code>。</p><h3 id="5-3-程序的执行"><a href="#5-3-程序的执行" class="headerlink" title="5.3 程序的执行"></a>5.3 程序的执行</h3><p>使用 <code>execute(file, arg1, ..., argn)</code>，我们能把 file 中的代码和数据全部替换，使这个新进程做我们想做的事。然而，<strong>打开文件，环境，进程间关系</strong>无法改变，因而这些一般需要在 <code>fork/execute</code> 之间做。</p><h3 id="5-4-进程间同步"><a href="#5-4-进程间同步" class="headerlink" title="5.4 进程间同步"></a>5.4 进程间同步</h3><p>有的时候，父进程需要等子进程退出。这可能是因为要避免“僵尸进程”，也有可能是为了时序。总之有这样两种指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> p = <span class="built_in">wait</span>(<span class="type">int</span> *stat_loc);</span><br><span class="line"><span class="type">pid_t</span> q = <span class="built_in">waitpid</span>(<span class="type">pid_t</span> pid, <span class="type">int</span>* stat_loc, <span class="type">int</span> options);</span><br></pre></td></tr></table></figure><p>前者会阻塞进程直到某个子进程结束，并返回其 pid，将返回状态存入 <code>stat_loc</code>。后者可以等待特定子进程结束，当 <code>pid</code> 为 -1 时则等待任意一个。同时，如果 <code>options = WNOHANG</code>，则这个过程是非阻塞的。另外，如果子进程不存在或意外终止，则返回 0。我们可以这样等待所有子进程结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="type">int</span> stat, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WHOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\tchild %d termininated\n&quot;</span>, ++i, pid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Shell"><a href="#6-Shell" class="headerlink" title="6. Shell"></a>6. Shell</h2><p>基本的功能不再赘述，我们可以看看 shell 是如何实现的。</p><p>我们可以基本构想它是如何运作的：首先我们运行一个进程来等用户输入一行指令，一旦这样，我们解析指令并进行 <code>fork</code>。子进程再根据参数进行 <code>execute</code>，最后父进程等待子进程退出，并输出结果，等待键盘的新输入。</p><p>当然，如果指令后有 <code>&amp;</code>，shell 会用一个线程来在后台运行这条指令，同时直接等输入。</p><p>关于重定向流，这是在 <code>fork/execute</code> 之间进行的。我们看到 <code>&gt;/&lt;</code> 的时候会会把所有到 <code>stdin/stdout</code>（即描述符 0&#x2F;1） 的内容重定向到给定文件的描述符。</p><p>对于 <code>sh &lt; file</code>，就相当于 <code>fork</code> 自己并以 <code>file</code> 作为输入。</p><h2 id="7-UNIX-的思想和意义"><a href="#7-UNIX-的思想和意义" class="headerlink" title="7. UNIX 的思想和意义"></a>7. UNIX 的思想和意义</h2><blockquote><p> The basic idea of the Unix philosophy is to build <strong>simple, clear, concise, modular code</strong> that is easy to extend and maintain.</p></blockquote><ul><li>简洁，<code>mount/link</code> 的抽象都是为了在形式上更加统一，也更加方便管理</li><li>交互式的 shell 让交互式系统有了比非交互式系统更多的功能</li><li>在设计上从小的功能入手，可以减轻读代码的压力，并方便 debug</li><li>从单一的功能入手，便于代码复用</li><li>……</li></ul><h2 id="8-reference"><a href="#8-reference" class="headerlink" title="8. reference"></a>8. reference</h2><ol><li><a href="https://blog.finxter.com/the-unix-philosophy/">the-UNIX-philosophy</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operation System </tag>
            
            <tag> Paper Reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random Thoughts About This Blog</title>
      <link href="/2024/02/18/Random-Thoughts-About-This-Blog/"/>
      <url>/2024/02/18/Random-Thoughts-About-This-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="装修博客和装修自己"><a href="#装修博客和装修自己" class="headerlink" title="装修博客和装修自己"></a>装修博客和装修自己</h1><h2 id="0-关于这个博客的产生"><a href="#0-关于这个博客的产生" class="headerlink" title="0. 关于这个博客的产生"></a>0. 关于这个博客的产生</h2><p>希望有一个自己的博客的念想，在很久以前就有了。上了大学之后，看到好友 Conless 和 DennyQi 都有非常炫酷的个人博客，当时就决心也要自己弄一个。然而，当时的我作为一个“零基础”学生，尚在程序设计和数据结构中摸爬滚打（这或许是个托词），于是便偷懒地在博客园上弄了一个账号，在上面开始发一点编译器优化和体系结构的笔记。至于数学课嘛，实在是没兴趣把一长串公式再敲一遍了，于是这个博客的“数学气息”就没那么浓厚了。</p><p><img src="/2024/02/18/Random-Thoughts-About-This-Blog/BlogDoc_1.png" alt="blog on cnblogs.com"></p><p>然后在今年寒假，因为想到“可能这个假期是最后一个自由的假期了”，于是就下定决心做到一些事情，为此还和许多朋友强调了自己在寒假中的雄心壮志。在诸多“决心”中，“拥有一个个人主页”成为了为数不多最后真正完成的事。</p><h2 id="1-关于这个博客的设计"><a href="#1-关于这个博客的设计" class="headerlink" title="1. 关于这个博客的设计"></a>1. 关于这个博客的设计</h2><h3 id="1-1-选择博客主题"><a href="#1-1-选择博客主题" class="headerlink" title="1.1 选择博客主题"></a>1.1 选择博客主题</h3><p>一开始我也看了很多 Hexo 中的模板，但都感觉“略显花哨”，还有点偏二次元风。而 academic page 对我一个大二学生来说又为时尚早。考虑到我希望这个博客能成为我的一个“传播知识，交流思想”的平台，且具有更多生活化的特性，于是就选择了更加简约的 <a href="https://github.com/probberechts/hexo-theme-cactus">cactus</a>。在各种配色方案中，初步选择了 white：</p><p><img src="/2024/02/18/Random-Thoughts-About-This-Blog/cactusTheme.png"></p><h3 id="1-2-第一版的改动"><a href="#1-2-第一版的改动" class="headerlink" title="1.2 第一版的改动"></a>1.2 第一版的改动</h3><p>这个风格本身已经很好了。但一方面，我对 Menlo 字体实在不感冒。不仅于此，我还是希望自己在原本设计的基础上有一些改动，<del>不要看起来太不走心了</del>。于是在查阅了一些基本的资料后，我开始动工：</p><p><img src="/2024/02/18/Random-Thoughts-About-This-Blog/first-draft.jpg"></p><p>然而可以看到，这一版看起来甚至不如原本的样子。究其原因，一方面是 cactus 原本的 markdown 渲染看起来不太舒服，另外一方面原因是 inline code 看起来实在是太奇怪了：奇怪的字体加上不知所云的虚线框。几番改动后都没有得到自己想要的结果，于是乎就放弃了。开始了和朋友社交+在家里弹吉他颓废的生活，每天用电脑基本也就是继续写 compiler optimization 了。</p><h3 id="1-3-现在这版的改动"><a href="#1-3-现在这版的改动" class="headerlink" title="1.3 现在这版的改动"></a>1.3 现在这版的改动</h3><p>春节假期里，不知怎的，我又想起了还有“烂尾的博客”这件事情，于是又决定重新 customize。</p><p>很幸运的是，当我在 GitHub 上闲逛，找 cactus 魔改版本的时候，看到了 SiriusNeo 学长的 <a href="https://github.com/SiriusNEO/hexo-theme-cactus-customized">修改版</a>，在顺藤摸瓜来到他的主页后，我能惊喜的看到许多关于博客设计的建议和方法。于是乎，这个修改过程就可以顺利进行了。基本在网页上检查+修改 style 文件+<code>hexo s -p 8000</code> 循环上升了。</p><p>具体而言，除了 cactus 封面上的改动，我大概做了这些修改：</p><ul><li><p>修改了 font 相关的配置，把文本改成了 Century&#x2F;Microsoft YaHei，看起来倒也顺眼。</p></li><li><p>修改了 Markdown 渲染的相关配置：</p><ul><li>修改了 H1&#x2F;H2&#x2F;H3 的大小，取消了 H3 的 underline</li><li>更改 inline code 的 background 为 <code>darken($color-background, 4%)</code>，贴近 Typora 的样式</li><li>根据 <a href="https://github.com/blinkfox/hexo-theme-matery/issues/119">这个 Issue</a> 解决了公式渲染的部分问题</li></ul></li><li><p>在封面上加了 Category 来部分填补空缺，也算往 index 里做了点修改</p></li><li><p><del>在 Alan 的提醒下才发现 Projects 是用 Markdown 渲染的</del></p></li></ul><h3 id="1-4-一些还没干的事情"><a href="#1-4-一些还没干的事情" class="headerlink" title="1.4 一些还没干的事情"></a>1.4 一些还没干的事情</h3><ul><li>换一个 avatar</li><li>开启评论</li><li>多记录记录生活</li></ul><h2 id="2-关于博客的名字"><a href="#2-关于博客的名字" class="headerlink" title="2. 关于博客的名字"></a>2. 关于博客的名字</h2><p>A Random Thought at Twilight 的中文名是暮色随想。想搭博客的那段时间正好比赛团在排这首歌，于是就取了这个名字。歌词中主人公“渴望走进更大的世界，探寻更多深邃的事物”的愿望也挺符合目前这个时间节点我学习&#x2F;生活的心境的。于是就这样取名啦！</p><h2 id="3-关于《暮色随想》这首歌的介绍"><a href="#3-关于《暮色随想》这首歌的介绍" class="headerlink" title="3. 关于《暮色随想》这首歌的介绍"></a>3. 关于《暮色随想》这首歌的介绍</h2><h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h3><blockquote><p>This piece originated from a long drive at night in Guizhou, a southwestern province of China. In the lyrics, there is an imaginary person who lives in the countryside, totally isolated by hills and mountains. He is depicting the gloomy scenery around him when the evening is coming, as well as his sincere hope to leave for the outside world. He imagined the ideal city life, surrounded by warm light in the streets, but he really wonders whether his dream would come true. In the end, the darkness is nigh in reality and leaves everything in peace.</p></blockquote><p>另外，这首歌的词曲作者均是 SJTU 合唱团的，身边能有这么有才华的学长学姐真的很幸运。</p><h3 id="3-2-歌词"><a href="#3-2-歌词" class="headerlink" title="3.2 歌词"></a>3.2 歌词</h3><blockquote><p>夜幕爬上山岗，轻风目送夕阳。<br>山中睡着村庄，也静默着月亮。<br>夜幕爬山山岗，星雾隐隐微茫。<br>我何时能踏向，山外无际远方？</p><p>蝉声渐起，喧闹收息。<br>暮霭挂上树梢，群山同这夜色拥抱。<br>我默默地祈祷，我的梦想被听到。</p><p>我有多么向往，乘着风去远方。<br>身披街灯暖光，陪伴我去远航。</p><p>我有多么向往，走在城市中央。<br>日夜街巷明亮，灯火编织希望。</p><p>只是每当风不再唱，大山依旧在我身旁。<br>黑夜融化我的梦想，余声回荡……</p><p>夜幕悄然而降，月安睡在溪旁。<br>我的理想能否，在夜空敲出星光？</p><p>我问大山，大山沉默不回答，<br>留下那月色伴我守望。</p></blockquote><h2 id="4-关于致谢"><a href="#4-关于致谢" class="headerlink" title="4. 关于致谢"></a>4. 关于致谢</h2><p>感谢 SiriusNeo 学长的帮助和 <a href="me.tric.space">他的主页</a> 上的相关文章。<br>感谢 (former) npy 和身边众多好友对配色&#x2F;主题选择的建议 <del>和对我审美的纠正</del>。</p>]]></content>
      
      
      <categories>
          
          <category> Random Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loop Optimization in Compiler</title>
      <link href="/2024/01/31/Loop-Optimization-in-Compiler/"/>
      <url>/2024/01/31/Loop-Optimization-in-Compiler/</url>
      
        <content type="html"><![CDATA[<h1 id="Loop-Optimization-in-Compiler"><a href="#Loop-Optimization-in-Compiler" class="headerlink" title="Loop Optimization in Compiler"></a>Loop Optimization in Compiler</h1><h2 id="0-概览"><a href="#0-概览" class="headerlink" title="0. 概览"></a>0. 概览</h2><p>之前，我们已经讨论过常量传播、死代码消除等优化算法。这可以帮助我们在写出“不好的”代码时进行充分的优化。但是，如果一个人的代码确实是“好”的（在SCCP&#x2F;ADCE）的角度下，那我们应该如何优化？</p><p>这个时候，我们便必须考虑循环优化。可以想见，一份代码中耗费时间最长的部分可能就是循环，那么显然优化循环是非常有价值的。</p><p>这里讨论的循环优化主要包含循环不变量外提&#x2F;归纳变量强度削弱&#x2F;循环展开等算法。（如果高编讲了的话，或许会更新一下多面体模型）</p><h2 id="1-如何识别循环"><a href="#1-如何识别循环" class="headerlink" title="1. 如何识别循环"></a>1. 如何识别循环</h2><p>直观上来说，循环就是一个基本块序列，其末尾能跳回开头。这里我们给出更加准确&#x2F;形式化的定义，即<strong>循环</strong>是一个包含满足以下性质的<strong>头结点</strong> $h$ 的结点集合 $S$：</p><ul><li>$S$ 中每个结点都能到达 $h$。</li><li>$h$ 能到达任何 $S$ 中的每个结点</li><li>没有 $S$ 外的结点到 $S$ 中非头结点的边。</li></ul><p>但按照这种定义来构建循环是较为困难的。这个时候我们考虑必经结点树。</p><p><img src="/../../public/images/Loop1.png"></p><p>考虑这张图，我们发现循环的另一个根本元素是一条回到头结点的边，称为回边。显然，头结点一定是循环内任何结点的必经结点，因而我们可以通过“指向必经结点的边”来识别出所有头结点和回边。进而根据上面的定义</p><h2 id="2-循环不变量计算"><a href="#2-循环不变量计算" class="headerlink" title="2. 循环不变量计算"></a>2. 循环不变量计算</h2><h2 id="3-归纳变量-强度削弱"><a href="#3-归纳变量-强度削弱" class="headerlink" title="3. 归纳变量&#x2F;强度削弱"></a>3. 归纳变量&#x2F;强度削弱</h2><p>直观来说，归纳变量说的是，如果循环中有一个以 $t$ 递增的变量 $i$，和一个等于 $i\cdot b + c$ 的变量 $j$。如果 $b, c$ 均为循环不变量，那么就可以用 $t\cdot b$ 来递增 $j$。</p><p>举个例子：考虑这么一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">getInt</span>(), b = <span class="built_in">getInt</span>(), c = <span class="built_in">getInt</span>(), d = <span class="built_in">getInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        j = <span class="number">4</span> * i + <span class="number">2</span>;</span><br><span class="line">        sum = sum + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printlnInt</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，我们完全不需要每次在循环中进行乘法，只要每次以 $4$ 递增变量 $j$ 就行了。</p><p>归纳变量变形的优化主要分为这么几步：第一，我们要从像 $i$ 这样的基础归纳变量 (basic induction variable) 开始发现导出归纳变量 (derived induction variable)，接着通过强度削弱 (strength reduction) 把原来的乘法变为加法。</p><h3 id="3-1-发现基本归纳变量"><a href="#3-1-发现基本归纳变量" class="headerlink" title="3.1 发现基本归纳变量"></a>3.1 发现基本归纳变量</h3><p>正如之前所说，如果在循环 $L$ 中，变量 $i$ 只有一个 $i \leftarrow i +c$ 的定值，其中 $c$ 是一个循环不变量，那么 $i$ 就是循环 $L$ 的基本归纳变量。</p><p>由于 llvm 是 SSA 的，我们可以注意到这样的 $i$ 的定值一定具有这样的形式：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%i_phi_0</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [ <span class="variable">%inc_0</span><span class="punctuation">,</span> <span class="variable">%for.inc_0</span> ]<span class="punctuation">,</span> [ <span class="number">0</span><span class="punctuation">,</span> <span class="variable">%enter_main_0</span> ]</span><br><span class="line"><span class="variable">%inc_0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_phi_0</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样的话，我们只需要找到循环头结点中所有的 $\phi$ 指令，考察其是否有两个分支，且其中一个在循环外，另一个再循环内且是循环外的那个来源加上一个循环不变量即可。</p><h3 id="3-2-发现导出归纳变量"><a href="#3-2-发现导出归纳变量" class="headerlink" title="3.2 发现导出归纳变量"></a>3.2 发现导出归纳变量</h3>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell script notes</title>
      <link href="/2024/01/21/shell-script-notes/"/>
      <url>/2024/01/21/shell-script-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-02-Shell-as-a-script-and-a-tool"><a href="#Lec-02-Shell-as-a-script-and-a-tool" class="headerlink" title="Lec 02: Shell as a script and a tool"></a>Lec 02: Shell as a script and a tool</h1><h2 id="0-概览"><a href="#0-概览" class="headerlink" title="0. 概览"></a>0. 概览</h2><p>shell 脚本是一种比较复杂的工具，可以用来优化创建命令&#x2F;执行&#x2F;读取的过程。这样比对应 c++ 程序要简单&#x2F;高效得多。</p><h2 id="1-Shell-脚本"><a href="#1-Shell-脚本" class="headerlink" title="1. Shell 脚本"></a>1. Shell 脚本</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p>如果要给变量赋值，我们可以使用 <code>foo=bar</code>，如果要访问变量的值，我们要使用 <code>$foo</code> 来访问。</p><p>值得注意的是，用 ‘ 和 “ 包括字符串的意义并不相同。前者不会转义，后者则会转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="comment"># 打印 bar</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="comment"># 打印 $foo</span></span><br></pre></td></tr></table></figure><h3 id="1-2-脚本"><a href="#1-2-脚本" class="headerlink" title="1.2 脚本"></a>1.2 脚本</h3><p>举个例子，如果我希望评测 <code>code.cpp</code> 中的代码，就可以这样写一个 judge 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">g++ code.cpp -o code</span><br><span class="line">./code &lt; 1.<span class="keyword">in</span> &gt; 1.out</span><br><span class="line">diff -qZB 1.out 1.ans</span><br></pre></td></tr></table></figure><p>第一行是为了告诉系统这是一个 bash 脚本，这样系统就会依次执行后面的代码。</p><p>下面我们写一个跑很多测试点的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 10); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> ./code &lt; <span class="variable">$i</span>.<span class="keyword">in</span> &gt; <span class="variable">$i</span>.out; <span class="keyword">then</span></span><br><span class="line">    diff -qZB <span class="variable">$i</span>.&#123;out.ans&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;RE for testpoint <span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="1-3-参数"><a href="#1-3-参数" class="headerlink" title="1.3 参数"></a>1.3 参数</h3><p>bash 有很多特殊的变量来表示参数、错误代码和相关变量。下面是一些例子：</p><ul><li><code>$0</code>-脚本名称</li><li><code>$1</code>-脚本的第一个参数</li><li><code>$@</code>-脚本的所有参数</li><li><code>$#</code>-参数个数</li><li><code>$$</code>-当前进程识别码</li><li><code>$?</code>-前一条指令的返回值</li><li><code>!!</code>-完整的上一条指令</li></ul><p>所有的非 0 返回值都代表运行时有错误，例如程序 <code>false</code>。</p><h3 id="1-4-替换"><a href="#1-4-替换" class="headerlink" title="1.4 替换"></a>1.4 替换</h3><p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 命令替换（command substitution）实现。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行 CMD 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。</p><p>例如，如果执行 <code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code> ，然后遍历得到的这些返回值。</p><p>还有一个冷门的类似特性是 进程替换（process substitution）， <code>&lt;( CMD )</code> 会执行 CMD 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 foo 和 bar 中文件的区别。</p><h3 id="1-5-综合的例子"><a href="#1-5-综合的例子" class="headerlink" title="1.5 综合的例子"></a>1.5 综合的例子</h3><p>这段脚本会遍历我们提供的参数，使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># date会被替换成日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    <span class="comment"># 如果模式没有找到，则grep退出状态为 1</span></span><br><span class="line">    <span class="comment"># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>感觉还是容易看懂的。需要注意的事情是比较操作最好用 <code>[[]]</code> 包括，这样会降低犯错的几率。</p><h3 id="1-6-glob"><a href="#1-6-glob" class="headerlink" title="1.6 glob"></a>1.6 glob</h3><p>bash 允许我们基于文件拓展名展开表达式。</p><ul><li>例如我可以用 <code>rm test/*.v</code> 来删除 test 目录下的所有 verilog 源文件 </li><li>又比如我可以通过 <code>&#123;&#125;</code> 来展示一些有公共子串的输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="comment"># 会展开为</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="comment"># 会展开为</span></span><br><span class="line"><span class="built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以结合通配使用</span></span><br><span class="line"><span class="built_in">mv</span> *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="comment"># 会移动所有 *.py 和 *.sh 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span></span><br><span class="line"><span class="built_in">touch</span> &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line"><span class="built_in">touch</span> foo/x bar/y</span><br><span class="line"><span class="comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">diff &lt;(<span class="built_in">ls</span> foo) &lt;(<span class="built_in">ls</span> bar)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># &lt; x</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="comment"># &gt; y</span></span><br></pre></td></tr></table></figure><h2 id="2-Shell-作为一种工具"><a href="#2-Shell-作为一种工具" class="headerlink" title="2. Shell 作为一种工具"></a>2. Shell 作为一种工具</h2><h3 id="2-1-查找文件"><a href="#2-1-查找文件" class="headerlink" title="2.1 查找文件"></a>2.1 查找文件</h3><p>find 是一种绝佳的查找工具（但是很慢）。它会递归地搜索符合条件的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br></pre></td></tr></table></figure><p>除了单纯的查找，我们还能对查找到的文件进行操作。这是通过 <code>-exec</code> 简述实现的。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><h3 id="2-2-查找代码"><a href="#2-2-查找代码" class="headerlink" title="2.2 查找代码"></a>2.2 查找代码</h3><p><code>grep</code> 指令是一个非常好的工具。其中有很多有用的参数：</p><ul><li><code>-C</code>: 获取查找结果的上下午，例如 <code>grep -C 10</code> 就是显示上下十行</li><li><code>-v</code> 选出不匹配的结果</li><li><code>-R</code> 递归进行子目录</li></ul><p>它也有一些替代品，例如 <code>rg</code>，你可以通过 <code>sudo apt install ripgrep</code> 来安装之。下面是一些使用的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester/2-Shell_script$ rg -t md <span class="string">&quot;#&quot;</span> // 查找所有用了 <span class="string">&#x27;#&#x27;</span> 的 .md 文件</span><br><span class="line">shell_script_notes.md</span><br><span class="line">1:<span class="comment"># Lec 02: Shell as a script and a tool</span></span><br><span class="line">3:<span class="comment">## 0. 概览</span></span><br><span class="line">6:<span class="comment">## 1. Shell 脚本</span></span><br><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester$ rg Denny -A 1 // 查找所有含有 <span class="string">&quot;Denny&quot;</span> 的文本，并输出上下一行</span><br><span class="line">1-Shell/shell_notes.md</span><br><span class="line">14:如果要传参数的话，我们可以使用单引号/双引号将其包括，也可以使用转移符号进行处理。比方说我要创建一个叫 <span class="string">&quot;Denny Qi&quot;</span> 的文件夹，就可以写：</span><br><span class="line">15-</span><br><span class="line">--</span><br><span class="line">17:invo1lution: <span class="built_in">mkdir</span> Denny\ Qi</span><br><span class="line">18-```</span><br><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester$ rg --stats qweryy // 打印匹配 <span class="string">&quot;qweryy&quot;</span> 的统计信息</span><br><span class="line">0 matches</span><br><span class="line">0 matched lines</span><br><span class="line">0 files contained matches</span><br><span class="line">4 files searched</span><br><span class="line">0 bytes printed</span><br><span class="line">11241 bytes searched</span><br><span class="line">0.000024 seconds spent searching</span><br><span class="line">0.005344 seconds</span><br></pre></td></tr></table></figure><h3 id="2-3-查找-shell-命令"><a href="#2-3-查找-shell-命令" class="headerlink" title="2.3 查找 shell 命令"></a>2.3 查找 shell 命令</h3><p>经典 <code>history | grep find</code>。这在编译器反复配 ravel 环境的时候帮了大忙。</p><p>同时，你也可以使用 <code>Ctrl + R</code> 来回溯，并输入字串进行匹配。</p><p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在 .bashrc 中添加 <code>HISTCONTROL=ignorespace</code> 或者向 .zshrc 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑 .bash_history 或 .zhistory 来手动地从历史记录中移除那一项。</p><h3 id="2-4-文件夹导航"><a href="#2-4-文件夹导航" class="headerlink" title="2.4 文件夹导航"></a>2.4 文件夹导航</h3><p><a href="https://github.com/clvv/fasd">fasd</a> 工具可以帮助我们根据日常习惯来访问经常访问的目录。具体细节可以查看该仓库的 <code>README.md</code></p><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol><li><a href="https://missing-semester-cn.github.io/2020/shell-tools/">MIT Missing-Semester Lec02</a></li><li><a href="https://acm.sjtu.edu.cn/wiki/Shell">ACM Class Wiki, shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing-Semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell notes</title>
      <link href="/2024/01/21/shell-notes/"/>
      <url>/2024/01/21/shell-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-01-Shell"><a href="#Lec-01-Shell" class="headerlink" title="Lec 01: Shell"></a>Lec 01: Shell</h1><h2 id="1-shell-的基本操作"><a href="#1-shell-的基本操作" class="headerlink" title="1. shell 的基本操作"></a>1. shell 的基本操作</h2><p>当你刚刚打开 Shell 的时候，你会发现这样一段提示符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invo1lution:~$</span><br></pre></td></tr></table></figure><ul><li>~ 的意思是 home。</li><li>$ 的意思是目前的身份不是 root 用户。</li></ul><hr><p>如果要传参数的话，我们可以使用单引号&#x2F;双引号将其包括，也可以使用转移符号进行处理。比方说我要创建一个叫 “Denny Qi” 的文件夹，就可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invo1lution: <span class="built_in">mkdir</span> Denny\ Qi</span><br></pre></td></tr></table></figure><hr><p>类似于 <code>echo mkdir</code> 这样的指令都是一段 shell 可以解释执行的尖端代码。如果某个指令并不是 shell 了解的关键字，它会咨询<strong>环境变量</strong> <code>$PATH</code>。这里举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><h2 id="2-在-shell-中导航"><a href="#2-在-shell-中导航" class="headerlink" title="2. 在 shell 中导航"></a>2. 在 shell 中导航</h2><p>这个已经很熟悉了。你可以通过 <code>pwd</code> 来获取当前目录。</p><h3 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h3><p>关于 <code>ls</code>：</p><ol><li>你可以通过 <code>-l</code> 来显示详细信息</li><li>通过 <code>-h</code> 来用 K&#x2F;M&#x2F;G 等看得懂的单位表示文件大小。</li><li>你可以通过 <code>-a</code> 来显示以 . 开头的隐藏文件。</li></ol><p>合起来就是 <code>ls -lah</code>。<br>这里举一个 <code>ls -l</code> 的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l /home</span><br><span class="line">drwxr-xr-x 1 missing  <span class="built_in">users</span>  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure><p>下面的九个字母分别代表<strong>文件所有者&#x2F;用户组&#x2F;其它所有人</strong> 的权限。如果你想进入某个文件夹，就需要具备它和它父文件夹的搜索权限，为了列出它，用户就需要对其有读权限。</p><h2 id="3-shell-的文本操作"><a href="#3-shell-的文本操作" class="headerlink" title="3. shell 的文本操作"></a>3. shell 的文本操作</h2><h3 id="3-1-cat"><a href="#3-1-cat" class="headerlink" title="3.1 cat"></a>3.1 cat</h3><p>你可以通过 <code>cat hello.cpp</code> 把文件里的东西输出到终端。</p><h3 id="3-2-echo"><a href="#3-2-echo" class="headerlink" title="3.2 echo"></a>3.2 echo</h3><p>你可以通过 <code>echo hi &gt; main.cpp</code> 来往文件里写东西</p><h3 id="3-3-Nano"><a href="#3-3-Nano" class="headerlink" title="3.3 Nano"></a>3.3 Nano</h3><p>关于 Nano，这里列出一些基本功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ nano hello.cpp</span><br><span class="line">  GNU nano <span class="number">6.4</span>                        hello.cpp                                 </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                                [ 已读取 <span class="number">5</span> 行 ]</span><br><span class="line">^G 帮助      ^O 写入      ^W 搜索      ^K 剪切      ^T 执行命令  ^C 位置</span><br><span class="line">^X 离开      ^R 读档      ^\ 替换      ^U 粘贴      ^J 对齐      ^/ 跳行</span><br></pre></td></tr></table></figure><p>其中例如 ^X 的意思就是 Ctrl + X，而 Alt + X 就是 M-x。</p><h3 id="3-4-cp-mv"><a href="#3-4-cp-mv" class="headerlink" title="3.4 cp&#x2F;mv"></a>3.4 cp&#x2F;mv</h3><p>你可以通过 <code>cp src dest</code> 来把 src 挪到 dest 里面。如果 src 是一个目录，就需要 <code>-r</code> 来表示递归复制。</p><p>另外，你可以通过 <code>mv src dest</code> 来直接移动文件&#x2F;目录，而且**不需要<code>-r</code>**。</p><h2 id="4-程序间创造连接"><a href="#4-程序间创造连接" class="headerlink" title="4. 程序间创造连接"></a>4. 程序间创造连接</h2><h3 id="4-1-输入输出重定向"><a href="#4-1-输入输出重定向" class="headerlink" title="4.1 输入输出重定向"></a>4.1 输入输出重定向</h3><p>在 Linux 系统里，一个程序默认有三条输入输出的通道：</p><ul><li>通道 0 表示标准输入 (<code>stdin / std::cin</code>)</li><li>通道 1 表示标准输出 (<code>stdout / std::cout</code>)</li><li>通道 2 表示标准错误 (<code>stderr / std::cerr</code>)<br>在 shell 里，我们可以把这三个通道重定向到文件 (类似于 <code>freopen</code>)。例如，如果我们要从 <code>1.in</code> 里读数据，输出到 <code>1.out</code> 里，并把标准错误写到 <code>1.err</code> 里，可以这样：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &lt;1.<span class="keyword">in</span> &gt;1.out 2&gt;1.err</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">1.err</span><br><span class="line">1.<span class="keyword">in</span></span><br><span class="line">1.out</span><br><span class="line">a.out</span><br><span class="line">hello.cpp</span><br></pre></td></tr></table></figure><p>务必注意：如果一个被输出文件在执行命令前已经存在了，那么它会在程序执行前先被<strong>清空</strong>。如果你不想让它被清空，而是想让程序输出到文件末尾，可以用 <code>&gt;&gt;</code> 代替 <code>&gt;</code>。</p><p>有时候我们想要把 <code>stdout</code> 和 <code>stderr</code> 的内容都输出到同一个文件里，这时候可以用 <code>2&gt;&amp;1</code>：</p><h2 id="5-一个功能强大的工具"><a href="#5-一个功能强大的工具" class="headerlink" title="5. 一个功能强大的工具"></a>5. 一个功能强大的工具</h2><p>root 即根用户，它想干什么都可以。但是我们不能登录之，因为这样的话某些错误的操作可能直接毁掉系统。所以我们使用 <code>sudo</code> 指令取代之。</p><p>有一件事情是必须作为根用户才能做得，就是往 <code>sysfs</code> 文件（包含内核参数）中写入内容。你的系统的很多信息都挂载在 <code>/sys</code> 下。</p><p>例如，你的屏幕亮度就在 <code>/sys/class/backlight</code> 文件中。</p><p>这里有一个重点，看下面这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">&#x27;*brightness*&#x27;</span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$ <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span><br><span class="line">$ sudo <span class="built_in">echo</span> 3 &gt; brightness</span><br><span class="line">An error occurred <span class="keyword">while</span> redirecting file <span class="string">&#x27;brightness&#x27;</span></span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure><p>这是因为 <code>| &gt; &lt;</code> 是通过 shell 执行的，后者在设置 <code>echo sudo</code> 之前尝试打开 brightness，所以失败了。</p><p>你可以使用 <code>$ echo 3 | sudo tee brightness</code> 作为替代。</p><h2 id="6-后台运行"><a href="#6-后台运行" class="headerlink" title="6. 后台运行"></a>6. 后台运行</h2><p>如果我们想同时在一个终端里运行多个指令，就可以用后台运行模式启动命令。只要在想运行的指令后面加一个 &amp; 就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &amp;</span><br><span class="line">[1] 64661</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>有的时候我们开着一个程序，但希望切到另一个程序。这时候可以先用 <code>Ctrl+Z</code> 把程序暂停运行。如果你想回到原来的程序，可以使用 <code>fg</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.10.6 (main, Aug  3 2022, 17:39:45) [GCC 12.1.1 20220730] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; Ctrl+Z</span><br><span class="line">[1]+  已停止               python3</span><br><span class="line">$ <span class="built_in">cat</span> data</span><br><span class="line">123 4566 7788</span><br><span class="line">$ <span class="built_in">fg</span></span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; 123 + 4566 + 7788</span><br><span class="line">12477</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure><h2 id="7-一些工具命令"><a href="#7-一些工具命令" class="headerlink" title="7. 一些工具命令"></a>7. 一些工具命令</h2><p>一些工具命令</p><ul><li><code>seq 起始 终止</code>：打印出起始到终止的所有整数（闭区间）。</li><li><code>sort</code>: 对输入以行为单位排序。</li><li><code>sed &#39;s/查找内容/替换内容/g&#39;</code> ：将输入里的所有查找内容替换为替换内容。</li><li><code>grep 查找内容</code>：在输入里查找查找内容。</li><li><code>which 命令</code>：输出命令的绝对路径。whereis 也有类似的功能。</li><li><code>ps</code>：输出这个终端里正在执行的程序（包含 shell 和 ps 本身）。</li><li><code>kill 进程编号、killall 程序名称</code>：发出信号让对应进程终止。</li><li><code>kill -9 进程编号、killall 程序名称</code>：发出信号让对应进程强行立即终止。</li></ul><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><ol><li><a href="https://missing-semester-cn.github.io/2020/course-shell/">MIT Missing-Semester Lec01</a></li><li><a href="https://acm.sjtu.edu.cn/wiki/Shell">ACM Class Wiki, shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing-Semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dead Code Elimination in Compiler</title>
      <link href="/2023/09/27/Dead-Code-Elimination-in-Compiler/"/>
      <url>/2023/09/27/Dead-Code-Elimination-in-Compiler/</url>
      
        <content type="html"><![CDATA[<h2 id="0-什么是死代码消除"><a href="#0-什么是死代码消除" class="headerlink" title="0. 什么是死代码消除"></a>0. 什么是死代码消除</h2><p>相信大家在写 <code>c++</code> 的时候，如果你定义了一个变量但是没有对其使用，大部分IDE都会对这个变量进行灰色的染色。又或者说，当你开了一个空的循环，在里面定义并使用了一堆和输出值&#x2F;返回值没有关系的变量，这个时候 IDE 也会提示你这个循环没有用。这背后都是用到了死代码消除的 Pass。</p><h2 id="1-死代码消除（Dead-Code-Elimination）"><a href="#1-死代码消除（Dead-Code-Elimination）" class="headerlink" title="1. 死代码消除（Dead Code Elimination）"></a>1. 死代码消除（Dead Code Elimination）</h2><h3 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1 算法思想"></a>1.1 算法思想</h3><p>我们在死代码消除中希望去掉所有不活跃的变量。那么什么是不活跃呢？容易想到这意味着它定义的变量在接下来会被使用到。注意到，我们是在 SSA 阶段进行的这个优化，这意味着对于每个变量，它的 $def$ 是它的每个 $use$ 的必经节点。那么我们可以基于工作表算法写出伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (存在某个没有使用点的变量 v &amp;&amp; 定值 v 的语句没有其他副作用) &#123;</span><br><span class="line">    删除定值 v 的这条语句</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="1-2-需要维护的信息"><a href="#1-2-需要维护的信息" class="headerlink" title="1.2 需要维护的信息"></a>1.2 需要维护的信息</h3><p>我们使用 <code>HashMap&lt;IRRegister&gt; myMap</code> 来维护现有的变量，并使用 <code>WorkList</code>。</p><p>同时，我们给出 <code>HashMap&lt;IRRegister, HashMap&lt;IRBaseInst&gt;&gt; useMap</code> 来记录所有变量的 <code>use</code>，用 <code>HashMap&lt;IRRegister, IRBaseInst&gt; defMap</code> 来记录所有变量的 <code>use</code>。</p><p>另外，我们注意到，函数的入参并不在我们的考量范围内（我们总不能消掉它们的 <code>def</code> 吧），所以我们需要用一个 <code>HashSet</code> 来记录当前函数的所有入参。</p><h3 id="1-3-算法实现"><a href="#1-3-算法实现" class="headerlink" title="1.3 算法实现"></a>1.3 算法实现</h3><p>大概的思路就是先把所有没有被使用到的定值语句加入工作表。接下来进行迭代，把这条语句中所有 $use$ 的定值语句都加入工作表。如果工作表中的一条指令没有被使用，就给它打上要删除的 tag，如此迭代直到工作表为空。</p><p>最后，我们只要把所有的打有 tag 的 $def$ 都删除就行了。</p><h3 id="1-4-效果总结"><a href="#1-4-效果总结" class="headerlink" title="1.4 效果总结"></a>1.4 效果总结</h3><p>其实，对于死代码消除而言，只要我们写的代码中所有 $def$ 的变量都被使用，其优化效果应该是比较差的。但是，我们注意到之前 $\text{Mem2Reg}$ 阶段对于所有的支配边界都插入了 $phi$ 指令。事实上，不是每个支配边界块之后都有对该变量的 $use$，自然，也不一定需要这么多的 <code>move</code> 语句。所以，一般来说，死代码消除消除的基本都是无效的 $phi$ 指令。</p><h2 id="2-激进的死代码消除（Aggressive-Dead-Code-Elimination）"><a href="#2-激进的死代码消除（Aggressive-Dead-Code-Elimination）" class="headerlink" title="2. 激进的死代码消除（Aggressive Dead Code Elimination）"></a>2. 激进的死代码消除（Aggressive Dead Code Elimination）</h2><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>它的思想和传统的死代码消除最不一样的地方就在于：它对于死代码的定义不同。</p><p>它的定义相当于是递归的：初始，我们定义<strong>所有调用函数，函数返回，对存储器的操作</strong>为有效代码。之后，我们标记一下语句为有效的：</p><ul><li>对其他有效语句的 $use$ 进行定值的语句</li><li>其他有效语句<strong>控制依赖于</strong>的语句（至于这个是什么，我们待会儿说）</li></ul><p>之后，我们迭代得到所有语句，并把剩下的都删除。那么接下来，我们首先展开<strong>控制依赖</strong>部分的内容，幸运的是，这一部分和支配树很像。</p><h3 id="2-2-控制依赖"><a href="#2-2-控制依赖" class="headerlink" title="2.2 控制依赖"></a>2.2 控制依赖</h3><p>我们希望回答的问题是，控制流图上的两个节点 $x,y$ 中，$x$ 能否直接控制节点 $y$ 的执行？</p><p>那么什么是控制执行呢？应该就是节点 $x$ 有一个后继 $u$ 能直接到达程序的 $exitBlock$ 而不经过 $y$。而它同时也有一个后继 $v$ 使得 $v$ 到 $exitBlock$ 的每一条路径都经过 $y$。</p><p>那么我们很容易就能得到控制依赖的等价定义。我们考虑 CFG 对应的反图，则在这张图上，$x\in domFrontier(y)$。因为 $x$ 的前驱 $v$ 被 $y$ 直接支配，而它又能由 $u$ 到达，因而 $x$ 在 $y$ 的支配边界上。</p><h3 id="2-3-算法实现"><a href="#2-3-算法实现" class="headerlink" title="2.3 算法实现"></a>2.3 算法实现</h3><p>我们需要维护的信息如下：</p><ol><li><code>HashSet&lt;IRBaseInst&gt; live</code>：所有的活跃指令</li><li><code>HashSet&lt;BasicBlock&gt; liveBlock</code>：所有有活跃指令的基本块</li><li><code>HashSet&lt;entity&gt; liveUse </code>：所有活跃指令的$use$</li><li><code>HashSet&lt;IRBaseInst&gt; workList</code>：用于迭代的工作表</li><li><code>HashSet&lt;IRRegister, IRBaseInst&gt; defMap</code>：所有变量的$def$语句</li></ol><p>首先，我们需要建出控制依赖图，这部分参考之前支配树构建的那期。</p><p>接下来，我们首先扫描该函数的所有基本块，将所有 $def$ 收集到<code>defMap</code>中，同时把所有的 <code>store</code>（代表修改全局变量，可能会在其他程序中用到）、所有的 <code>call</code>、所有的 <code>ret</code> 加入 <code>workList</code>。</p><p>然后，我们进行迭代。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!workList.isEmpty()) &#123;</span><br><span class="line">    <span class="type">IRBaseInst</span> <span class="variable">inst</span> <span class="operator">=</span> workList.iterator().next();</span><br><span class="line">    workList.remove(inst);</span><br><span class="line">    live.add(inst);</span><br><span class="line">    liveBlock.add(inst.parentBlock);</span><br><span class="line">    liveUse.addAll(inst.uses());</span><br><span class="line">    <span class="keyword">if</span> (inst <span class="keyword">instanceof</span> IRPhi irPhi) &#123; <span class="comment">// 对于一条phi指令，它的每一个前驱都应当被标注为活跃的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> block : irPhi.blockMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (block.terminal != <span class="literal">null</span> &amp;&amp; !live.contains(block.terminal)) &#123;</span><br><span class="line">                workList.add(block.terminal);</span><br><span class="line">                liveBlock.add(block);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> cdg_pred : inst.parentBlock.cdg_pred) &#123; <span class="comment">// 加入该块的所有控制依赖前驱</span></span><br><span class="line">        <span class="keyword">if</span> (cdg_pred.terminal != <span class="literal">null</span> &amp;&amp; !live.contains(cdg_pred.terminal)) &#123;</span><br><span class="line">            workList.add(cdg_pred.terminal); <span class="comment">// 注意已经加过的不用加了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> use : inst.uses()) &#123; <span class="comment">// 对于其每个use的变量，将其def加入workList</span></span><br><span class="line">        <span class="keyword">if</span> (!(use <span class="keyword">instanceof</span> IRRegister) || use <span class="keyword">instanceof</span> IRGlobalVar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">IRBaseInst</span> <span class="variable">def</span> <span class="operator">=</span> defMap.get(use);</span><br><span class="line">        <span class="keyword">if</span> (def != <span class="literal">null</span> &amp;&amp; !live.contains(def)) &#123;</span><br><span class="line">            workList.add(def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们遍历所有指令，消去不活跃的 $phi$ 指令和普通指令。</p><p>这里有一个细节，就是 <code>jump/branch</code> 这样的 <code>terminal</code> 的处理。如果一个块的 <code>terminal</code> 被标记为不活跃的，那么这个块应该跳到哪里呢？自然，它应当跳到它的后继中第一个活跃的块上。我们要在反支配树上寻找（反支配树就是我们根据 CFG 的反图建出的支配树）。</p><p>我们断言，如果一个节点 $x$ 是不活跃的，那么说 $x$ 到 $anti\_dom(x)$ 的这些节点一定都不是活跃的如果其中有一个节点是活跃的，那么根据定义，一定能通过若干次 $dominanceFrontier$ 的迭代，推出 $x$ 是活跃的。那么我们只需要不停地迭代 <code>target=target.anti_dom</code> 就行了。</p><h3 id="2-4-ADCE对程序语义的影响"><a href="#2-4-ADCE对程序语义的影响" class="headerlink" title="2.4 ADCE对程序语义的影响"></a>2.4 ADCE对程序语义的影响</h3><p>它的一个弊端在于它会删除不活跃的死循环，从而改变语义（这很明显）。在许多环境下，这被认为是不可接受的。</p><h3 id="2-5-ADCE的效果"><a href="#2-5-ADCE的效果" class="headerlink" title="2.5 ADCE的效果"></a>2.5 ADCE的效果</h3><p>基本与DCE类似，主要在冗余 $phi$ 的消除。它的另一个增益在于能消除掉无用的控制流语句。</p><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p>[1] 现代编译原理（C语言实现）Chapter 19.5</p>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown Test Page</title>
      <link href="/2005/09/07/Markdown-Test-Page/"/>
      <url>/2005/09/07/Markdown-Test-Page/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-Syntax"><a href="#Markdown-Syntax" class="headerlink" title="Markdown: Syntax"></a>Markdown: Syntax</h1><ul><li><a href="#markdown-syntax">Markdown: Syntax</a><ul><li><a href="#overview">Overview</a><ul><li><a href="#philosophy">Philosophy</a></li></ul></li><li><a href="#block-elements">Block Elements</a><ul><li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a></li><li><a href="#headers">Headers</a></li><li><a href="#blockquotes">Blockquotes</a></li><li><a href="#lists">Lists</a></li><li><a href="#code-blocks">Code Blocks</a></li></ul></li><li><a href="#span-elements">Span Elements</a><ul><li><a href="#links">Links</a></li><li><a href="#emphasis">Emphasis</a></li><li><a href="#code">Code</a></li></ul></li></ul></li></ul><p><strong>Note:</strong> This document is itself written using Markdown; you can <a href="/projects/markdown/syntax.text">see the source for it by adding ‘.text’ to the URL</a>.</p><hr><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h3><p>Markdown is intended to be as easy-to-read and easy-to-write as is feasible.</p><p>Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters – including <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>, <a href="http://www.aaronsw.com/2002/atx/">atx</a>, <a href="http://textism.com/tools/textile/">Textile</a>, <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>, <a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a>, and <a href="http://ettext.taint.org/doc/">EtText</a> – the single biggest source of inspiration for Markdown’s syntax is the format of plain text email.</p><h2 id="Block-Elements"><a href="#Block-Elements" class="headerlink" title="Block Elements"></a>Block Elements</h2><h3 id="Paragraphs-and-Line-Breaks"><a href="#Paragraphs-and-Line-Breaks" class="headerlink" title="Paragraphs and Line Breaks"></a>Paragraphs and Line Breaks</h3><p>A paragraph is simply one or more consecutive lines of text, separated by one or more blank lines. (A blank line is any line that looks like a blank line – a line containing nothing but spaces or tabs is considered blank.) Normal paragraphs should not be indented with spaces or tabs.</p><p>The implication of the “one or more consecutive lines of text” rule is that Markdown supports “hard-wrapped” text paragraphs. This differs significantly from most other text-to-HTML formatters (including Movable Type’s “Convert Line Breaks” option) which translate every line break character in a paragraph into a <code>&lt;br /&gt;</code> tag.</p><p>When you <em>do</em> want to insert a <code>&lt;br /&gt;</code> break tag using Markdown, you end a line with two or more spaces, then type return.</p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Markdown supports two styles of headers, [Setext] [1] and [atx] [2].</p><p>Optionally, you may “close” atx-style headers. This is purely cosmetic – you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.)</p><h3 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h3><p>Markdown uses email-style <code>&gt;</code> characters for blockquoting. If you’re familiar with quoting passages of text in an email message, then you know how to create a blockquote in Markdown. It looks best if you hard wrap the text and put a <code>&gt;</code> before every line:</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Markdown allows you to be lazy and only put the <code>&gt;</code> before the first line of a hard-wrapped paragraph:</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of <code>&gt;</code>:</p><blockquote><p>This is the first level of quoting.</p><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level.</p></blockquote><p>Blockquotes can contain other Markdown elements, including headers, lists, and code blocks:</p><blockquote><p>## This is a header.</p><ol><li>This is the first list item.</li><li>This is the second list item.</li></ol><p>Here’s some example code:</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><p>Any decent text editor should make email-style quoting easy. For example, with BBEdit, you can make a selection and choose Increase Quote Level from the Text menu.</p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p><p>Unordered lists use asterisks, pluses, and hyphens – interchangably – as list markers:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>is equivalent to:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>and:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>Ordered lists use numbers followed by periods:</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>It’s important to note that the actual numbers you use to mark the list have no effect on the HTML output Markdown produces. The HTML Markdown produces from the above list is:</p><p>If you instead wrote the list in Markdown like this:</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>or even:</p><ol start="3"><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>you’d get the exact same HTML output. The point is, if you want to, you can use ordinal numbers in your ordered Markdown lists, so that the numbers in your source match the numbers in your published HTML. But if you want to be lazy, you don’t have to.</p><p>To make lists look nice, you can wrap items with hanging indents:</p><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li></ul><p>But if you want to be lazy, you don’t have to:</p><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li></ul><p>List items may consist of multiple paragraphs. Each subsequent paragraph in a list item must be indented by either 4 spaces or one tab:</p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>It looks nice if you indent every line of the subsequent paragraphs, but here again, Markdown will allow you to be lazy:</p><ul><li><p>This is a list item with two paragraphs.</p><p>This is the second paragraph in the list item. You’re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</p></li><li><p>Another item in the same list.</p></li></ul><p>To put a blockquote within a list item, the blockquote’s <code>&gt;</code> delimiters need to be indented:</p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul><p>To put a code block within a list item, the code block needs to be indented <em>twice</em> – 8 spaces or two tabs:</p><ul><li><p>A list item with a code block:</p><pre><code>&lt;code goes here&gt;</code></pre></li></ul><h3 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h3><p>Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally. Markdown wraps a code block in both <code>&lt;pre&gt;</code> and <code>&lt;code&gt;</code> tags.</p><p>To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.</p><p>This is a normal paragraph:</p><pre><code>This is a code block.</code></pre><p>Here is an example of AppleScript:</p><pre><code>tell application &quot;Foo&quot;    beepend tell</code></pre><p>A code block continues until it reaches a line that is not indented (or the end of the article).</p><p>Within a code block, ampersands (<code>&amp;</code>) and angle brackets (<code>&lt;</code> and <code>&gt;</code>) are automatically converted into HTML entities. This makes it very easy to include example HTML source code using Markdown – just paste it and indent it, and Markdown will handle the hassle of encoding the ampersands and angle brackets. For example, this:</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><p>Regular Markdown syntax is not processed within code blocks. E.g., asterisks are just literal asterisks within a code block. This means it’s also easy to use Markdown to write about Markdown’s own syntax.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><h2 id="Span-Elements"><a href="#Span-Elements" class="headerlink" title="Span Elements"></a>Span Elements</h2><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><p>Markdown supports two style of links: <em>inline</em> and <em>reference</em>.</p><p>In both styles, the link text is delimited by [square brackets].</p><p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an <em>optional</em> title for the link, surrounded in quotes. For example:</p><p>This is <a href="http://example.com/">an example</a> inline link.</p><p><a href="http://example.net/">This link</a> has no title attribute.</p><h3 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h3><p>Markdown treats asterisks (<code>*</code>) and underscores (<code>_</code>) as indicators of emphasis. Text wrapped with one <code>*</code> or <code>_</code> will be wrapped with an HTML <code>&lt;em&gt;</code> tag; double <code>*</code>‘s or <code>_</code>‘s will be wrapped with an HTML <code>&lt;strong&gt;</code> tag. E.g., this input:</p><p><em>single asterisks</em></p><p><em>single underscores</em></p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>To indicate a span of code, wrap it with backtick quotes (<code>`</code>). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example:</p><p>Use the <code>printf()</code> function.</p>]]></content>
      
      
      <categories>
          
          <category> Random Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
