<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Loop Optimization in Compiler</title>
      <link href="/2024/01/31/Loop-Optimization-in-Compiler/"/>
      <url>/2024/01/31/Loop-Optimization-in-Compiler/</url>
      
        <content type="html"><![CDATA[<h1 id="Loop-Optimization-in-Compiler"><a href="#Loop-Optimization-in-Compiler" class="headerlink" title="Loop Optimization in Compiler"></a>Loop Optimization in Compiler</h1><h2 id="1-循环"><a href="#1-循环" class="headerlink" title="1. 循环"></a>1. 循环</h2><h2 id="3-归纳变量"><a href="#3-归纳变量" class="headerlink" title="3. 归纳变量"></a>3. 归纳变量</h2><p>直观来说，归纳变量说的是，如果循环中有一个以 $t$ 递增的变量 $i$，和一个等于 $i\cdot b + c$ 的变量 $j$。如果 $b, c$ 均为循环不变量，那么就可以用 $t\cdot b$ 来递增 $j$。</p><p>举个例子：考虑这么一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">getInt</span>(), b = <span class="built_in">getInt</span>(), c = <span class="built_in">getInt</span>(), d = <span class="built_in">getInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        j = <span class="number">4</span> * i + <span class="number">2</span>;</span><br><span class="line">        sum = sum + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printlnInt</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不经优化的话，我们会得到：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line"></span><br><span class="line">enter_main_<span class="number">0</span>:</span><br><span class="line"><span class="variable">%_1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getInt</span>()</span><br><span class="line"><span class="variable">%_3</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getInt</span>()</span><br><span class="line"><span class="variable">%_5</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getInt</span>()</span><br><span class="line"><span class="variable">%_7</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@getInt</span>()</span><br><span class="line"><span class="keyword">br</span> label <span class="variable">%for.cond_0</span></span><br><span class="line"></span><br><span class="line">for.cond_<span class="number">0</span>:</span><br><span class="line"><span class="variable">%sum_phi_0</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [ <span class="variable">%add_1</span><span class="punctuation">,</span> <span class="variable">%for.inc_0</span> ]<span class="punctuation">,</span> [ <span class="number">0</span><span class="punctuation">,</span> <span class="variable">%enter_main_0</span> ]</span><br><span class="line"><span class="variable">%i_phi_0</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [ <span class="variable">%inc_0</span><span class="punctuation">,</span> <span class="variable">%for.inc_0</span> ]<span class="punctuation">,</span> [ <span class="number">0</span><span class="punctuation">,</span> <span class="variable">%enter_main_0</span> ]</span><br><span class="line"><span class="variable">%slt_0</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_phi_0</span><span class="punctuation">,</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%slt_0</span><span class="punctuation">,</span> label <span class="variable">%for.body_0</span><span class="punctuation">,</span> label <span class="variable">%for.end_0</span></span><br><span class="line"></span><br><span class="line">for.inc_<span class="number">0</span>:</span><br><span class="line"><span class="variable">%inc_0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_phi_0</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">br</span> label <span class="variable">%for.cond_0</span></span><br><span class="line"></span><br><span class="line">for.body_<span class="number">0</span>:</span><br><span class="line"><span class="variable">%mul_0</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="number">4</span><span class="punctuation">,</span> <span class="variable">%i_phi_0</span></span><br><span class="line"><span class="variable">%add_0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%mul_0</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%add_1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%sum_phi_0</span><span class="punctuation">,</span> <span class="variable">%add_0</span></span><br><span class="line"><span class="keyword">br</span> label <span class="variable">%for.inc_0</span></span><br><span class="line"></span><br><span class="line">for.end_<span class="number">0</span>:</span><br><span class="line"><span class="keyword">call</span> void <span class="title">@printlnInt</span>(<span class="type">i32</span> <span class="variable">%sum_phi_0</span>)</span><br><span class="line"><span class="keyword">br</span> label <span class="variable">%exit_main_0</span></span><br><span class="line"></span><br><span class="line">exit_main_<span class="number">0</span>:</span><br><span class="line"><span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化的话，我们会得到：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dick</span><br></pre></td></tr></table></figure><p>其中一个来源是它在循环前的初始值，另一个来源是它在循环中累加的过程</p><p>归纳变量变形的优化主要分为这么几步：第一，我们要从像 $i$ 这样的基础归纳变量 (basic induction variable) 开始发现导出归纳变量 (derived induction variable)，接着通过强度削弱 (strength reduction) 把原来的乘法变为加法。</p><h3 id="3-1-发现基本归纳变量"><a href="#3-1-发现基本归纳变量" class="headerlink" title="3.1 发现基本归纳变量"></a>3.1 发现基本归纳变量</h3><p>正如之前所说，如果在循环 $L$ 中，变量 $i$ 只有一个 $i \leftarrow i +c$ 的定值，其中 $c$ 是一个循环不变量，那么 $i$ 就是循环 $L$ 的基本归纳变量。</p><p>由于 llvm 是 SSA 的，我们可以注意到这样的 $i$ 的定值一定具有这样的形式：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%i_phi_0</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [ <span class="variable">%inc_0</span><span class="punctuation">,</span> <span class="variable">%for.inc_0</span> ]<span class="punctuation">,</span> [ <span class="number">0</span><span class="punctuation">,</span> <span class="variable">%enter_main_0</span> ]</span><br><span class="line"><span class="variable">%inc_0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_phi_0</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样的话，我们只需要找到循环头节点中所有的 $\phi$ 指令，考察其是否有两个分支，且其中一个在循环外，另一个再循环内且是循环外的那个来源加上一个循环不变量即可。</p><h3 id="3-2-发现导出归纳变量"><a href="#3-2-发现导出归纳变量" class="headerlink" title="3.2 发现导出归纳变量"></a>3.2 发现导出归纳变量</h3>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell script notes</title>
      <link href="/2024/01/21/shell-script-notes/"/>
      <url>/2024/01/21/shell-script-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-02-Shell-as-a-script-and-a-tool"><a href="#Lec-02-Shell-as-a-script-and-a-tool" class="headerlink" title="Lec 02: Shell as a script and a tool"></a>Lec 02: Shell as a script and a tool</h1><h2 id="0-概览"><a href="#0-概览" class="headerlink" title="0. 概览"></a>0. 概览</h2><p>shell 脚本是一种比较复杂的工具，可以用来优化创建命令&#x2F;执行&#x2F;读取的过程。这样比对应 c++ 程序要简单&#x2F;高效得多。</p><h2 id="1-Shell-脚本"><a href="#1-Shell-脚本" class="headerlink" title="1. Shell 脚本"></a>1. Shell 脚本</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p>如果要给变量赋值，我们可以使用 <code>foo=bar</code>，如果要访问变量的值，我们要使用 <code>$foo</code> 来访问。</p><p>值得注意的是，用 ‘ 和 “ 包括字符串的意义并不相同。前者不会转义，后者则会转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="comment"># 打印 bar</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="comment"># 打印 $foo</span></span><br></pre></td></tr></table></figure><h3 id="1-2-脚本"><a href="#1-2-脚本" class="headerlink" title="1.2 脚本"></a>1.2 脚本</h3><p>举个例子，如果我希望评测 <code>code.cpp</code> 中的代码，就可以这样写一个 judge 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">g++ code.cpp -o code</span><br><span class="line">./code &lt; 1.<span class="keyword">in</span> &gt; 1.out</span><br><span class="line">diff -qZB 1.out 1.ans</span><br></pre></td></tr></table></figure><p>第一行是为了告诉系统这是一个 bash 脚本，这样系统就会依次执行后面的代码。</p><p>下面我们写一个跑很多测试点的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 10); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> ./code &lt; <span class="variable">$i</span>.<span class="keyword">in</span> &gt; <span class="variable">$i</span>.out; <span class="keyword">then</span></span><br><span class="line">    diff -qZB <span class="variable">$i</span>.&#123;out.ans&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;RE for testpoint <span class="variable">$i</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="1-3-参数"><a href="#1-3-参数" class="headerlink" title="1.3 参数"></a>1.3 参数</h3><p>bash 有很多特殊的变量来表示参数、错误代码和相关变量。下面是一些例子：</p><ul><li><code>$0</code>-脚本名称</li><li><code>$1</code>-脚本的第一个参数</li><li><code>$@</code>-脚本的所有参数</li><li><code>$#</code>-参数个数</li><li><code>$$</code>-当前进程识别码</li><li><code>$?</code>-前一条指令的返回值</li><li><code>!!</code>-完整的上一条指令</li></ul><p>所有的非 0 返回值都代表运行时有错误，例如程序 <code>false</code>。</p><h3 id="1-4-替换"><a href="#1-4-替换" class="headerlink" title="1.4 替换"></a>1.4 替换</h3><p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 命令替换（command substitution）实现。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行 CMD 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。</p><p>例如，如果执行 <code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code> ，然后遍历得到的这些返回值。</p><p>还有一个冷门的类似特性是 进程替换（process substitution）， <code>&lt;( CMD )</code> 会执行 CMD 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 foo 和 bar 中文件的区别。</p><h3 id="1-5-综合的例子"><a href="#1-5-综合的例子" class="headerlink" title="1.5 综合的例子"></a>1.5 综合的例子</h3><p>这段脚本会遍历我们提供的参数，使用 <code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># date会被替换成日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    <span class="comment"># 如果模式没有找到，则grep退出状态为 1</span></span><br><span class="line">    <span class="comment"># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>感觉还是容易看懂的。需要注意的事情是比较操作最好用 <code>[[]]</code> 包括，这样会降低犯错的几率。</p><h3 id="1-6-glob"><a href="#1-6-glob" class="headerlink" title="1.6 glob"></a>1.6 glob</h3><p>bash 允许我们基于文件拓展名展开表达式。</p><ul><li>例如我可以用 <code>rm test/*.v</code> 来删除 test 目录下的所有 verilog 源文件 </li><li>又比如我可以通过 <code>&#123;&#125;</code> 来展示一些有公共子串的输入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="comment"># 会展开为</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="comment"># 会展开为</span></span><br><span class="line"><span class="built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以结合通配使用</span></span><br><span class="line"><span class="built_in">mv</span> *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="comment"># 会移动所有 *.py 和 *.sh 文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span></span><br><span class="line"><span class="built_in">touch</span> &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line"><span class="built_in">touch</span> foo/x bar/y</span><br><span class="line"><span class="comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">diff &lt;(<span class="built_in">ls</span> foo) &lt;(<span class="built_in">ls</span> bar)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># &lt; x</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="comment"># &gt; y</span></span><br></pre></td></tr></table></figure><h2 id="2-Shell-作为一种工具"><a href="#2-Shell-作为一种工具" class="headerlink" title="2. Shell 作为一种工具"></a>2. Shell 作为一种工具</h2><h3 id="2-1-查找文件"><a href="#2-1-查找文件" class="headerlink" title="2.1 查找文件"></a>2.1 查找文件</h3><p>find 是一种绝佳的查找工具（但是很慢）。它会递归地搜索符合条件的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">&#x27;*/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">&#x27;*.tar.gz&#x27;</span></span><br></pre></td></tr></table></figure><p>除了单纯的查找，我们还能对查找到的文件进行操作。这是通过 <code>-exec</code> 简述实现的。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><h3 id="2-2-查找代码"><a href="#2-2-查找代码" class="headerlink" title="2.2 查找代码"></a>2.2 查找代码</h3><p><code>grep</code> 指令是一个非常好的工具。其中有很多有用的参数：</p><ul><li><code>-C</code>: 获取查找结果的上下午，例如 <code>grep -C 10</code> 就是显示上下十行</li><li><code>-v</code> 选出不匹配的结果</li><li><code>-R</code> 递归进行子目录</li></ul><p>它也有一些替代品，例如 <code>rg</code>，你可以通过 <code>sudo apt install ripgrep</code> 来安装之。下面是一些使用的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester/2-Shell_script$ rg -t md <span class="string">&quot;#&quot;</span> // 查找所有用了 <span class="string">&#x27;#&#x27;</span> 的 .md 文件</span><br><span class="line">shell_script_notes.md</span><br><span class="line">1:<span class="comment"># Lec 02: Shell as a script and a tool</span></span><br><span class="line">3:<span class="comment">## 0. 概览</span></span><br><span class="line">6:<span class="comment">## 1. Shell 脚本</span></span><br><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester$ rg Denny -A 1 // 查找所有含有 <span class="string">&quot;Denny&quot;</span> 的文本，并输出上下一行</span><br><span class="line">1-Shell/shell_notes.md</span><br><span class="line">14:如果要传参数的话，我们可以使用单引号/双引号将其包括，也可以使用转移符号进行处理。比方说我要创建一个叫 <span class="string">&quot;Denny Qi&quot;</span> 的文件夹，就可以写：</span><br><span class="line">15-</span><br><span class="line">--</span><br><span class="line">17:invo1lution: <span class="built_in">mkdir</span> Denny\ Qi</span><br><span class="line">18-```</span><br><span class="line">brucelee@invo1ution:~/Interest/Missing-Semester$ rg --stats qweryy // 打印匹配 <span class="string">&quot;qweryy&quot;</span> 的统计信息</span><br><span class="line">0 matches</span><br><span class="line">0 matched lines</span><br><span class="line">0 files contained matches</span><br><span class="line">4 files searched</span><br><span class="line">0 bytes printed</span><br><span class="line">11241 bytes searched</span><br><span class="line">0.000024 seconds spent searching</span><br><span class="line">0.005344 seconds</span><br></pre></td></tr></table></figure><h3 id="2-3-查找-shell-命令"><a href="#2-3-查找-shell-命令" class="headerlink" title="2.3 查找 shell 命令"></a>2.3 查找 shell 命令</h3><p>经典 <code>history | grep find</code>。这在编译器反复配 ravel 环境的时候帮了大忙。</p><p>同时，你也可以使用 <code>Ctrl + R</code> 来回溯，并输入字串进行匹配。</p><p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在 .bashrc 中添加 <code>HISTCONTROL=ignorespace</code> 或者向 .zshrc 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑 .bash_history 或 .zhistory 来手动地从历史记录中移除那一项。</p><h3 id="2-4-文件夹导航"><a href="#2-4-文件夹导航" class="headerlink" title="2.4 文件夹导航"></a>2.4 文件夹导航</h3><p><a href="https://github.com/clvv/fasd">fasd</a> 工具可以帮助我们根据日常习惯来访问经常访问的目录。具体细节可以查看该仓库的 <code>README.md</code></p><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol><li><a href="https://missing-semester-cn.github.io/2020/shell-tools/">MIT Missing-Semester Lec02</a></li><li><a href="https://acm.sjtu.edu.cn/wiki/Shell">ACM Class Wiki, shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing-Semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell notes</title>
      <link href="/2024/01/21/shell-notes/"/>
      <url>/2024/01/21/shell-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-01-Shell"><a href="#Lec-01-Shell" class="headerlink" title="Lec 01: Shell"></a>Lec 01: Shell</h1><h2 id="1-shell-的基本操作"><a href="#1-shell-的基本操作" class="headerlink" title="1. shell 的基本操作"></a>1. shell 的基本操作</h2><p>当你刚刚打开 Shell 的时候，你会发现这样一段提示符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invo1lution:~$</span><br></pre></td></tr></table></figure><ul><li>~ 的意思是 home。</li><li>$ 的意思是目前的身份不是 root 用户。</li></ul><hr><p>如果要传参数的话，我们可以使用单引号&#x2F;双引号将其包括，也可以使用转移符号进行处理。比方说我要创建一个叫 “Denny Qi” 的文件夹，就可以写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invo1lution: <span class="built_in">mkdir</span> Denny\ Qi</span><br></pre></td></tr></table></figure><hr><p>类似于 <code>echo mkdir</code> 这样的指令都是一段 shell 可以解释执行的尖端代码。如果某个指令并不是 shell 了解的关键字，它会咨询<strong>环境变量</strong> <code>$PATH</code>。这里举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo <span class="variable">$PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><h2 id="2-在-shell-中导航"><a href="#2-在-shell-中导航" class="headerlink" title="2. 在 shell 中导航"></a>2. 在 shell 中导航</h2><p>这个已经很熟悉了。你可以通过 <code>pwd</code> 来获取当前目录。</p><h3 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h3><p>关于 <code>ls</code>：</p><ol><li>你可以通过 <code>-l</code> 来显示详细信息</li><li>通过 <code>-h</code> 来用 K&#x2F;M&#x2F;G 等看得懂的单位表示文件大小。</li><li>你可以通过 <code>-a</code> 来显示以 . 开头的隐藏文件。</li></ol><p>合起来就是 <code>ls -lah</code>。<br>这里举一个 <code>ls -l</code> 的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ <span class="built_in">ls</span> -l /home</span><br><span class="line">drwxr-xr-x 1 missing  <span class="built_in">users</span>  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure><p>下面的九个字母分别代表<strong>文件所有者&#x2F;用户组&#x2F;其它所有人</strong> 的权限。如果你想进入某个文件夹，就需要具备它和它父文件夹的搜索权限，为了列出它，用户就需要对其有读权限。</p><h2 id="3-shell-的文本操作"><a href="#3-shell-的文本操作" class="headerlink" title="3. shell 的文本操作"></a>3. shell 的文本操作</h2><h3 id="3-1-cat"><a href="#3-1-cat" class="headerlink" title="3.1 cat"></a>3.1 cat</h3><p>你可以通过 <code>cat hello.cpp</code> 把文件里的东西输出到终端。</p><h3 id="3-2-echo"><a href="#3-2-echo" class="headerlink" title="3.2 echo"></a>3.2 echo</h3><p>你可以通过 <code>echo hi &gt; main.cpp</code> 来往文件里写东西</p><h3 id="3-3-Nano"><a href="#3-3-Nano" class="headerlink" title="3.3 Nano"></a>3.3 Nano</h3><p>关于 Nano，这里列出一些基本功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ nano hello.cpp</span><br><span class="line">  GNU nano <span class="number">6.4</span>                        hello.cpp                                 </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                                [ 已读取 <span class="number">5</span> 行 ]</span><br><span class="line">^G 帮助      ^O 写入      ^W 搜索      ^K 剪切      ^T 执行命令  ^C 位置</span><br><span class="line">^X 离开      ^R 读档      ^\ 替换      ^U 粘贴      ^J 对齐      ^/ 跳行</span><br></pre></td></tr></table></figure><p>其中例如 ^X 的意思就是 Ctrl + X，而 Alt + X 就是 M-x。</p><h3 id="3-4-cp-mv"><a href="#3-4-cp-mv" class="headerlink" title="3.4 cp&#x2F;mv"></a>3.4 cp&#x2F;mv</h3><p>你可以通过 <code>cp src dest</code> 来把 src 挪到 dest 里面。如果 src 是一个目录，就需要 <code>-r</code> 来表示递归复制。</p><p>另外，你可以通过 <code>mv src dest</code> 来直接移动文件&#x2F;目录，而且**不需要<code>-r</code>**。</p><h2 id="4-程序间创造连接"><a href="#4-程序间创造连接" class="headerlink" title="4. 程序间创造连接"></a>4. 程序间创造连接</h2><h3 id="4-1-输入输出重定向"><a href="#4-1-输入输出重定向" class="headerlink" title="4.1 输入输出重定向"></a>4.1 输入输出重定向</h3><p>在 Linux 系统里，一个程序默认有三条输入输出的通道：</p><ul><li>通道 0 表示标准输入 (<code>stdin / std::cin</code>)</li><li>通道 1 表示标准输出 (<code>stdout / std::cout</code>)</li><li>通道 2 表示标准错误 (<code>stderr / std::cerr</code>)<br>在 shell 里，我们可以把这三个通道重定向到文件 (类似于 <code>freopen</code>)。例如，如果我们要从 <code>1.in</code> 里读数据，输出到 <code>1.out</code> 里，并把标准错误写到 <code>1.err</code> 里，可以这样：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &lt;1.<span class="keyword">in</span> &gt;1.out 2&gt;1.err</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">1.err</span><br><span class="line">1.<span class="keyword">in</span></span><br><span class="line">1.out</span><br><span class="line">a.out</span><br><span class="line">hello.cpp</span><br></pre></td></tr></table></figure><p>务必注意：如果一个被输出文件在执行命令前已经存在了，那么它会在程序执行前先被<strong>清空</strong>。如果你不想让它被清空，而是想让程序输出到文件末尾，可以用 <code>&gt;&gt;</code> 代替 <code>&gt;</code>。</p><p>有时候我们想要把 <code>stdout</code> 和 <code>stderr</code> 的内容都输出到同一个文件里，这时候可以用 <code>2&gt;&amp;1</code>：</p><h2 id="5-一个功能强大的工具"><a href="#5-一个功能强大的工具" class="headerlink" title="5. 一个功能强大的工具"></a>5. 一个功能强大的工具</h2><p>root 即根用户，它想干什么都可以。但是我们不能登录之，因为这样的话某些错误的操作可能直接毁掉系统。所以我们使用 <code>sudo</code> 指令取代之。</p><p>有一件事情是必须作为根用户才能做得，就是往 <code>sysfs</code> 文件（包含内核参数）中写入内容。你的系统的很多信息都挂载在 <code>/sys</code> 下。</p><p>例如，你的屏幕亮度就在 <code>/sys/class/backlight</code> 文件中。</p><p>这里有一个重点，看下面这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">&#x27;*brightness*&#x27;</span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$ <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span><br><span class="line">$ sudo <span class="built_in">echo</span> 3 &gt; brightness</span><br><span class="line">An error occurred <span class="keyword">while</span> redirecting file <span class="string">&#x27;brightness&#x27;</span></span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure><p>这是因为 <code>| &gt; &lt;</code> 是通过 shell 执行的，后者在设置 <code>echo sudo</code> 之前尝试打开 brightness，所以失败了。</p><p>你可以使用 <code>$ echo 3 | sudo tee brightness</code> 作为替代。</p><h2 id="6-后台运行"><a href="#6-后台运行" class="headerlink" title="6. 后台运行"></a>6. 后台运行</h2><p>如果我们想同时在一个终端里运行多个指令，就可以用后台运行模式启动命令。只要在想运行的指令后面加一个 &amp; 就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &amp;</span><br><span class="line">[1] 64661</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>有的时候我们开着一个程序，但希望切到另一个程序。这时候可以先用 <code>Ctrl+Z</code> 把程序暂停运行。如果你想回到原来的程序，可以使用 <code>fg</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.10.6 (main, Aug  3 2022, 17:39:45) [GCC 12.1.1 20220730] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; Ctrl+Z</span><br><span class="line">[1]+  已停止               python3</span><br><span class="line">$ <span class="built_in">cat</span> data</span><br><span class="line">123 4566 7788</span><br><span class="line">$ <span class="built_in">fg</span></span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; 123 + 4566 + 7788</span><br><span class="line">12477</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure><h2 id="7-一些工具命令"><a href="#7-一些工具命令" class="headerlink" title="7. 一些工具命令"></a>7. 一些工具命令</h2><p>一些工具命令</p><ul><li><code>seq 起始 终止</code>：打印出起始到终止的所有整数（闭区间）。</li><li><code>sort</code>: 对输入以行为单位排序。</li><li><code>sed &#39;s/查找内容/替换内容/g&#39;</code> ：将输入里的所有查找内容替换为替换内容。</li><li><code>grep 查找内容</code>：在输入里查找查找内容。</li><li><code>which 命令</code>：输出命令的绝对路径。whereis 也有类似的功能。</li><li><code>ps</code>：输出这个终端里正在执行的程序（包含 shell 和 ps 本身）。</li><li><code>kill 进程编号、killall 程序名称</code>：发出信号让对应进程终止。</li><li><code>kill -9 进程编号、killall 程序名称</code>：发出信号让对应进程强行立即终止。</li></ul><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><ol><li><a href="https://missing-semester-cn.github.io/2020/course-shell/">MIT Missing-Semester Lec01</a></li><li><a href="https://acm.sjtu.edu.cn/wiki/Shell">ACM Class Wiki, shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing-Semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dead Code Elimination in Compiler</title>
      <link href="/2023/09/27/Dead-Code-Elimination-in-Compiler/"/>
      <url>/2023/09/27/Dead-Code-Elimination-in-Compiler/</url>
      
        <content type="html"><![CDATA[<h2 id="0-什么是死代码消除"><a href="#0-什么是死代码消除" class="headerlink" title="0. 什么是死代码消除"></a>0. 什么是死代码消除</h2><p>相信大家在写 <code>c++</code> 的时候，如果你定义了一个变量但是没有对其使用，大部分IDE都会对这个变量进行灰色的染色。又或者说，当你开了一个空的循环，在里面定义并使用了一堆和输出值&#x2F;返回值没有关系的变量，这个时候 IDE 也会提示你这个循环没有用。这背后都是用到了死代码消除的 Pass。</p><h2 id="1-死代码消除（Dead-Code-Elimination）"><a href="#1-死代码消除（Dead-Code-Elimination）" class="headerlink" title="1. 死代码消除（Dead Code Elimination）"></a>1. 死代码消除（Dead Code Elimination）</h2><h3 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1 算法思想"></a>1.1 算法思想</h3><p>我们在死代码消除中希望去掉所有不活跃的变量。那么什么是不活跃呢？容易想到这意味着它定义的变量在接下来会被使用到。注意到，我们是在 SSA 阶段进行的这个优化，这意味着对于每个变量，它的 $def$ 是它的每个 $use$ 的必经节点。那么我们可以基于工作表算法写出伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (存在某个没有使用点的变量 v &amp;&amp; 定值 v 的语句没有其他副作用) &#123;</span><br><span class="line">    删除定值 v 的这条语句</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="1-2-需要维护的信息"><a href="#1-2-需要维护的信息" class="headerlink" title="1.2 需要维护的信息"></a>1.2 需要维护的信息</h3><p>我们使用 <code>HashMap&lt;IRRegister&gt; myMap</code> 来维护现有的变量，并使用 <code>WorkList</code>。</p><p>同时，我们给出 <code>HashMap&lt;IRRegister, HashMap&lt;IRBaseInst&gt;&gt; useMap</code> 来记录所有变量的 <code>use</code>，用 <code>HashMap&lt;IRRegister, IRBaseInst&gt; defMap</code> 来记录所有变量的 <code>use</code>。</p><p>另外，我们注意到，函数的入参并不在我们的考量范围内（我们总不能消掉它们的 <code>def</code> 吧），所以我们需要用一个 <code>HashSet</code> 来记录当前函数的所有入参。</p><h3 id="1-3-算法实现"><a href="#1-3-算法实现" class="headerlink" title="1.3 算法实现"></a>1.3 算法实现</h3><p>大概的思路就是先把所有没有被使用到的定值语句加入工作表。接下来进行迭代，把这条语句中所有 $use$ 的定值语句都加入工作表。如果工作表中的一条指令没有被使用，就给它打上要删除的 tag，如此迭代直到工作表为空。</p><p>最后，我们只要把所有的打有 tag 的 $def$ 都删除就行了。</p><h3 id="1-4-效果总结"><a href="#1-4-效果总结" class="headerlink" title="1.4 效果总结"></a>1.4 效果总结</h3><p>其实，对于死代码消除而言，只要我们写的代码中所有 $def$ 的变量都被使用，其优化效果应该是比较差的。但是，我们注意到之前 $\text{Mem2Reg}$ 阶段对于所有的支配边界都插入了 $phi$ 指令。事实上，不是每个支配边界块之后都有对该变量的 $use$，自然，也不一定需要这么多的 <code>move</code> 语句。所以，一般来说，死代码消除消除的基本都是无效的 $phi$ 指令。</p><h2 id="2-激进的死代码消除（Aggressive-Dead-Code-Elimination）"><a href="#2-激进的死代码消除（Aggressive-Dead-Code-Elimination）" class="headerlink" title="2. 激进的死代码消除（Aggressive Dead Code Elimination）"></a>2. 激进的死代码消除（Aggressive Dead Code Elimination）</h2><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>它的思想和传统的死代码消除最不一样的地方就在于：它对于死代码的定义不同。</p><p>它的定义相当于是递归的：初始，我们定义<strong>所有调用函数，函数返回，对存储器的操作</strong>为有效代码。之后，我们标记一下语句为有效的：</p><ul><li>对其他有效语句的 $use$ 进行定值的语句</li><li>其他有效语句<strong>控制依赖于</strong>的语句（至于这个是什么，我们待会儿说）</li></ul><p>之后，我们迭代得到所有语句，并把剩下的都删除。那么接下来，我们首先展开<strong>控制依赖</strong>部分的内容，幸运的是，这一部分和支配树很像。</p><h3 id="2-2-控制依赖"><a href="#2-2-控制依赖" class="headerlink" title="2.2 控制依赖"></a>2.2 控制依赖</h3><p>我们希望回答的问题是，控制流图上的两个节点 $x,y$ 中，$x$ 能否直接控制节点 $y$ 的执行？</p><p>那么什么是控制执行呢？应该就是节点 $x$ 有一个后继 $u$ 能直接到达程序的 $exitBlock$ 而不经过 $y$。而它同时也有一个后继 $v$ 使得 $v$ 到 $exitBlock$ 的每一条路径都经过 $y$。</p><p>那么我们很容易就能得到控制依赖的等价定义。我们考虑 CFG 对应的反图，则在这张图上，$x\in domFrontier(y)$。因为 $x$ 的前驱 $v$ 被 $y$ 直接支配，而它又能由 $u$ 到达，因而 $x$ 在 $y$ 的支配边界上。</p><h3 id="2-3-算法实现"><a href="#2-3-算法实现" class="headerlink" title="2.3 算法实现"></a>2.3 算法实现</h3><p>我们需要维护的信息如下：</p><ol><li><code>HashSet&lt;IRBaseInst&gt; live</code>：所有的活跃指令</li><li><code>HashSet&lt;BasicBlock&gt; liveBlock</code>：所有有活跃指令的基本块</li><li><code>HashSet&lt;entity&gt; liveUse </code>：所有活跃指令的$use$</li><li><code>HashSet&lt;IRBaseInst&gt; workList</code>：用于迭代的工作表</li><li><code>HashSet&lt;IRRegister, IRBaseInst&gt; defMap</code>：所有变量的$def$语句</li></ol><p>首先，我们需要建出控制依赖图，这部分参考之前支配树构建的那期。</p><p>接下来，我们首先扫描该函数的所有基本块，将所有 $def$ 收集到<code>defMap</code>中，同时把所有的 <code>store</code>（代表修改全局变量，可能会在其他程序中用到）、所有的 <code>call</code>、所有的 <code>ret</code> 加入 <code>workList</code>。</p><p>然后，我们进行迭代。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!workList.isEmpty()) &#123;</span><br><span class="line">    <span class="type">IRBaseInst</span> <span class="variable">inst</span> <span class="operator">=</span> workList.iterator().next();</span><br><span class="line">    workList.remove(inst);</span><br><span class="line">    live.add(inst);</span><br><span class="line">    liveBlock.add(inst.parentBlock);</span><br><span class="line">    liveUse.addAll(inst.uses());</span><br><span class="line">    <span class="keyword">if</span> (inst <span class="keyword">instanceof</span> IRPhi irPhi) &#123; <span class="comment">// 对于一条phi指令，它的每一个前驱都应当被标注为活跃的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> block : irPhi.blockMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (block.terminal != <span class="literal">null</span> &amp;&amp; !live.contains(block.terminal)) &#123;</span><br><span class="line">                workList.add(block.terminal);</span><br><span class="line">                liveBlock.add(block);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> cdg_pred : inst.parentBlock.cdg_pred) &#123; <span class="comment">// 加入该块的所有控制依赖前驱</span></span><br><span class="line">        <span class="keyword">if</span> (cdg_pred.terminal != <span class="literal">null</span> &amp;&amp; !live.contains(cdg_pred.terminal)) &#123;</span><br><span class="line">            workList.add(cdg_pred.terminal); <span class="comment">// 注意已经加过的不用加了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> use : inst.uses()) &#123; <span class="comment">// 对于其每个use的变量，将其def加入workList</span></span><br><span class="line">        <span class="keyword">if</span> (!(use <span class="keyword">instanceof</span> IRRegister) || use <span class="keyword">instanceof</span> IRGlobalVar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">IRBaseInst</span> <span class="variable">def</span> <span class="operator">=</span> defMap.get(use);</span><br><span class="line">        <span class="keyword">if</span> (def != <span class="literal">null</span> &amp;&amp; !live.contains(def)) &#123;</span><br><span class="line">            workList.add(def);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们遍历所有指令，消去不活跃的 $phi$ 指令和普通指令。</p><p>这里有一个细节，就是 <code>jump/branch</code> 这样的 <code>terminal</code> 的处理。如果一个块的 <code>terminal</code> 被标记为不活跃的，那么这个块应该跳到哪里呢？自然，它应当跳到它的后继中第一个活跃的块上。我们要在反支配树上寻找（反支配树就是我们根据 CFG 的反图建出的支配树）。</p><p>我们断言，如果一个节点 $x$ 是不活跃的，那么说 $x$ 到 $anti\_dom(x)$ 的这些节点一定都不是活跃的如果其中有一个节点是活跃的，那么根据定义，一定能通过若干次 $dominanceFrontier$ 的迭代，推出 $x$ 是活跃的。那么我们只需要不停地迭代 <code>target=target.anti_dom</code> 就行了。</p><h3 id="2-4-ADCE对程序语义的影响"><a href="#2-4-ADCE对程序语义的影响" class="headerlink" title="2.4 ADCE对程序语义的影响"></a>2.4 ADCE对程序语义的影响</h3><p>它的一个弊端在于它会删除不活跃的死循环，从而改变语义（这很明显）。在许多环境下，这被认为是不可接受的。</p><h3 id="2-5-ADCE的效果"><a href="#2-5-ADCE的效果" class="headerlink" title="2.5 ADCE的效果"></a>2.5 ADCE的效果</h3><p>基本与DCE类似，主要在冗余 $phi$ 的消除。它的另一个增益在于能消除掉无用的控制流语句。</p><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p>[1] 现代编译原理（C语言实现）Chapter 19.5</p>]]></content>
      
      
      <categories>
          
          <category> Course-Related </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown Test Page</title>
      <link href="/2005/09/07/Markdown-Test-Page/"/>
      <url>/2005/09/07/Markdown-Test-Page/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-Syntax"><a href="#Markdown-Syntax" class="headerlink" title="Markdown: Syntax"></a>Markdown: Syntax</h1><ul><li><a href="#markdown-syntax">Markdown: Syntax</a><ul><li><a href="#overview">Overview</a><ul><li><a href="#philosophy">Philosophy</a></li></ul></li><li><a href="#block-elements">Block Elements</a><ul><li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a></li><li><a href="#headers">Headers</a></li><li><a href="#blockquotes">Blockquotes</a></li><li><a href="#lists">Lists</a></li><li><a href="#code-blocks">Code Blocks</a></li></ul></li><li><a href="#span-elements">Span Elements</a><ul><li><a href="#links">Links</a></li><li><a href="#emphasis">Emphasis</a></li><li><a href="#code">Code</a></li></ul></li></ul></li></ul><p><strong>Note:</strong> This document is itself written using Markdown; you can <a href="/projects/markdown/syntax.text">see the source for it by adding ‘.text’ to the URL</a>.</p><hr><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h3><p>Markdown is intended to be as easy-to-read and easy-to-write as is feasible.</p><p>Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters – including <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>, <a href="http://www.aaronsw.com/2002/atx/">atx</a>, <a href="http://textism.com/tools/textile/">Textile</a>, <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>, <a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a>, and <a href="http://ettext.taint.org/doc/">EtText</a> – the single biggest source of inspiration for Markdown’s syntax is the format of plain text email.</p><h2 id="Block-Elements"><a href="#Block-Elements" class="headerlink" title="Block Elements"></a>Block Elements</h2><h3 id="Paragraphs-and-Line-Breaks"><a href="#Paragraphs-and-Line-Breaks" class="headerlink" title="Paragraphs and Line Breaks"></a>Paragraphs and Line Breaks</h3><p>A paragraph is simply one or more consecutive lines of text, separated by one or more blank lines. (A blank line is any line that looks like a blank line – a line containing nothing but spaces or tabs is considered blank.) Normal paragraphs should not be indented with spaces or tabs.</p><p>The implication of the “one or more consecutive lines of text” rule is that Markdown supports “hard-wrapped” text paragraphs. This differs significantly from most other text-to-HTML formatters (including Movable Type’s “Convert Line Breaks” option) which translate every line break character in a paragraph into a <code>&lt;br /&gt;</code> tag.</p><p>When you <em>do</em> want to insert a <code>&lt;br /&gt;</code> break tag using Markdown, you end a line with two or more spaces, then type return.</p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Markdown supports two styles of headers, [Setext] [1] and [atx] [2].</p><p>Optionally, you may “close” atx-style headers. This is purely cosmetic – you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.)</p><h3 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h3><p>Markdown uses email-style <code>&gt;</code> characters for blockquoting. If you’re familiar with quoting passages of text in an email message, then you know how to create a blockquote in Markdown. It looks best if you hard wrap the text and put a <code>&gt;</code> before every line:</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Markdown allows you to be lazy and only put the <code>&gt;</code> before the first line of a hard-wrapped paragraph:</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of <code>&gt;</code>:</p><blockquote><p>This is the first level of quoting.</p><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level.</p></blockquote><p>Blockquotes can contain other Markdown elements, including headers, lists, and code blocks:</p><blockquote><p>## This is a header.</p><ol><li>This is the first list item.</li><li>This is the second list item.</li></ol><p>Here’s some example code:</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><p>Any decent text editor should make email-style quoting easy. For example, with BBEdit, you can make a selection and choose Increase Quote Level from the Text menu.</p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p><p>Unordered lists use asterisks, pluses, and hyphens – interchangably – as list markers:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>is equivalent to:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>and:</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>Ordered lists use numbers followed by periods:</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>It’s important to note that the actual numbers you use to mark the list have no effect on the HTML output Markdown produces. The HTML Markdown produces from the above list is:</p><p>If you instead wrote the list in Markdown like this:</p><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>or even:</p><ol start="3"><li>Bird</li><li>McHale</li><li>Parish</li></ol><p>you’d get the exact same HTML output. The point is, if you want to, you can use ordinal numbers in your ordered Markdown lists, so that the numbers in your source match the numbers in your published HTML. But if you want to be lazy, you don’t have to.</p><p>To make lists look nice, you can wrap items with hanging indents:</p><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li></ul><p>But if you want to be lazy, you don’t have to:</p><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</li></ul><p>List items may consist of multiple paragraphs. Each subsequent paragraph in a list item must be indented by either 4 spaces or one tab:</p><ol><li><p>This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</p><p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</p></li><li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li></ol><p>It looks nice if you indent every line of the subsequent paragraphs, but here again, Markdown will allow you to be lazy:</p><ul><li><p>This is a list item with two paragraphs.</p><p>This is the second paragraph in the list item. You’re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</p></li><li><p>Another item in the same list.</p></li></ul><p>To put a blockquote within a list item, the blockquote’s <code>&gt;</code> delimiters need to be indented:</p><ul><li><p>A list item with a blockquote:</p><blockquote><p>This is a blockquote<br>inside a list item.</p></blockquote></li></ul><p>To put a code block within a list item, the code block needs to be indented <em>twice</em> – 8 spaces or two tabs:</p><ul><li><p>A list item with a code block:</p><pre><code>&lt;code goes here&gt;</code></pre></li></ul><h3 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h3><p>Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally. Markdown wraps a code block in both <code>&lt;pre&gt;</code> and <code>&lt;code&gt;</code> tags.</p><p>To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.</p><p>This is a normal paragraph:</p><pre><code>This is a code block.</code></pre><p>Here is an example of AppleScript:</p><pre><code>tell application &quot;Foo&quot;    beepend tell</code></pre><p>A code block continues until it reaches a line that is not indented (or the end of the article).</p><p>Within a code block, ampersands (<code>&amp;</code>) and angle brackets (<code>&lt;</code> and <code>&gt;</code>) are automatically converted into HTML entities. This makes it very easy to include example HTML source code using Markdown – just paste it and indent it, and Markdown will handle the hassle of encoding the ampersands and angle brackets. For example, this:</p><pre><code>&lt;div class=&quot;footer&quot;&gt;    &amp;copy; 2004 Foo Corporation&lt;/div&gt;</code></pre><p>Regular Markdown syntax is not processed within code blocks. E.g., asterisks are just literal asterisks within a code block. This means it’s also easy to use Markdown to write about Markdown’s own syntax.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure><h2 id="Span-Elements"><a href="#Span-Elements" class="headerlink" title="Span Elements"></a>Span Elements</h2><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><p>Markdown supports two style of links: <em>inline</em> and <em>reference</em>.</p><p>In both styles, the link text is delimited by [square brackets].</p><p>To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an <em>optional</em> title for the link, surrounded in quotes. For example:</p><p>This is <a href="http://example.com/">an example</a> inline link.</p><p><a href="http://example.net/">This link</a> has no title attribute.</p><h3 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h3><p>Markdown treats asterisks (<code>*</code>) and underscores (<code>_</code>) as indicators of emphasis. Text wrapped with one <code>*</code> or <code>_</code> will be wrapped with an HTML <code>&lt;em&gt;</code> tag; double <code>*</code>‘s or <code>_</code>‘s will be wrapped with an HTML <code>&lt;strong&gt;</code> tag. E.g., this input:</p><p><em>single asterisks</em></p><p><em>single underscores</em></p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>To indicate a span of code, wrap it with backtick quotes (<code>`</code>). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example:</p><p>Use the <code>printf()</code> function.</p>]]></content>
      
      
      <categories>
          
          <category> Random Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
